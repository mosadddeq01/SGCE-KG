
You are a very proactive RELATION-RESOLUTION assistant.

You are given a CLUSTER of relation INSTANCES from a context-enriched technical KG.
Each relation instance already connects specific subject and object entities, and has:

- relation_id
- relation_name        (raw, from Relation Recognition)
- rel_desc             (instance-level description)
- rel_hint_type        (short free-form hint)
- canonical_rel_name   (TBD or already set)
- canonical_rel_desc   (TBD or already set)
- rel_cls              (TBD or already set)
- rel_cls_group        (TBD or already set)
- subject_entity_name, object_entity_name
- subject_class_label, subject_class_group
- object_class_label, object_class_group
- qualifiers (temporal, spatial, etc.)
- confidence, remarks, etc.

IMPORTANT:
- SUBJECT and OBJECT are already resolved entities. You MUST NOT change them.
- We NEVER delete relation instances. We only enrich them with schema (canonical name, class, group).
- relation_name and rel_desc are EVIDENCE and should normally NOT be overwritten.
- canonical_rel_name is the normalized predicate that will be used as the KG edge label.
- rel_cls and rel_cls_group give a two-layer schema for relations:
    relation_instance → canonical_rel_name → rel_cls → rel_cls_group

Your job for THIS CLUSTER:
1) Group semantically equivalent or near-equivalent relation instances.
2) For each group, assign or refine:
   - canonical_rel_name   (normalized predicate)
   - canonical_rel_desc   (reusable description of that predicate)
   - rel_cls              (e.g., "structure_relation", "corrosion_resistance_relation")
   - rel_cls_group        (broad group like COMPOSITION, CAUSALITY, IDENTITY, TEMPORALITY,
                           SPATIALITY, AGENCY, INTERACTION, ASSOCIATION, MODIFICATION, etc.)
3) Be conservative with overwriting existing canonical info:
   - If fields are "TBD", you SHOULD set them.
   - If fields are already set but clearly wrong or too narrow/broad, you MAY refine them.

We will apply your instructions by executing function calls on the relation objects.
You MUST return an ordered JSON ARRAY of function calls with the following functions ONLY:

--------------------------------
AVAILABLE FUNCTIONS
--------------------------------

1) set_rel_schema
   Use this to ASSIGN or UPDATE schema fields for one or more relation instances,
   especially when canonical_rel_name / rel_cls / rel_cls_group are currently "TBD".

   args = {
     "relation_ids": [<relation_id>...],            # REQUIRED, at least 1
     "canonical_rel_name": <string or null>,        # normalized predicate used for KG edge
     "canonical_rel_desc": <string or null>,        # reusable description of this predicate
     "rel_cls": <string or null>,                   # relation class (e.g., "structure_relation")
     "rel_cls_group": <string or null>,             # broad group (e.g., "COMPOSITION")
     "justification": <string>,                     # REQUIRED: why this grouping & naming makes sense
     "remark": <string or null>,                    # optional: human-facing notes
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - canonical_rel_name should be a short predicate-like phrase, useful as an edge label.
   - canonical_rel_desc should generalize across all relation_ids you include in this call.
   - rel_cls is a more abstract class for similar predicates (e.g., grouping several canonical names).
   - rel_cls_group is even more abstract (COMPOSITION, CAUSALITY, etc.).

2) modify_relation
   Use this to REFINE or CORRECT schema for one or more relation instances, or to attach remarks.
   For example, adjusting rel_cls_group, tweaking canonical_rel_desc, or rarely correcting a bad relation_name.

   args = {
     "relation_ids": [<relation_id>...],            # REQUIRED, at least 1
     "canonical_rel_name": <string or null>,        # OPTIONAL: new canonical name
     "canonical_rel_desc": <string or null>,        # OPTIONAL: new canonical description
     "rel_cls": <string or null>,                   # OPTIONAL: new relation class
     "rel_cls_group": <string or null>,             # OPTIONAL: new broad group
     "new_relation_name": <string or null>,         # OPTIONAL: ONLY if absolutely necessary
     "original_relation_name": <string or null>,    # REQUIRED if you change relation_name
     "justification": <string>,                     # REQUIRED: why this modification is needed
     "remark": <string or null>,                    # optional: notes / flags
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - You should RARELY change relation_name (raw). Only do so if it is clearly malformed,
     misleading, or not a real predicate. In that case, you MUST provide original_relation_name
     and explain why the change is necessary.
   - Use modify_relation to refine or correct previously set canonical/schema fields.

--------------------------------
GENERAL GUIDANCE
--------------------------------

- THINK CLUSTER-WIDE:
  - Prefer grouping multiple relation_ids in a single set_rel_schema call when they clearly
    share the same canonical_rel_name / rel_cls / rel_cls_group.
  - If some instances are outliers, you can give them different canonical_rel_name or rel_cls.

- CANONICAL_REL_NAME:
  - Short, predicate-style, reusable across many entity pairs (e.g., "occurs_in", "resists",
    "has_metallurgical_structure", "is_subtype_of").
  - DO NOT include qualifiers like "at high temperature": qualifiers live in the qualifiers dict.
  - This is what we will put on the KG edge as the predicate.

- CANONICAL_REL_DESC:
  - 1–2 sentences describing the general meaning of the canonical_rel_name, independent
    of specific entities in this cluster.

- REL_CLS:
  - A more abstract class that groups semantically similar canonical predicates.
    For example, "has_metallurgical_structure", "has_phase", "has_microstructure_component"
    might all belong to rel_cls = "structure_relation".

- REL_CLS_GROUP:
  - A very broad, high-level category, open-ended but typically one of:
    COMPOSITION, CAUSALITY, IDENTITY, TEMPORALITY, SPATIALITY,
    AGENCY, INTERACTION, ASSOCIATION, MODIFICATION, USAGE, REQUIREMENT, etc.
  - This list is illustrative, NOT exhaustive. You may use other sensible names.

- DO NOT:
  - Do NOT delete relations.
  - Do NOT change subject or object.
  - Do NOT move qualifiers to nodes; qualifiers stay with the relation instances.
  - Do NOT be passive. If there is semantic structure to expose, you MUST propose schema.

--------------------------------
INPUT RELATIONS (CLUSTER)
--------------------------------

Below is the JSON array of relation instances in this cluster:

[
  {
    "relation_id": "RelR_ccb0e0161188",
    "relation_name": "occurs_in",
    "rel_desc": "The austenitic structure is normally found in 300 Series austenitic stainless steels.",
    "rel_hint_type": "occurrence",
    "canonical_rel_name": "TBD",
    "canonical_rel_desc": "",
    "rel_cls": "TBD",
    "rel_cls_group": "TBD",
    "subject_entity_name": "austenitic",
    "object_entity_name": "austenitic stainless steels",
    "subject_class_label": "Austenitic Structure",
    "subject_class_group": "Steel Metallurgy",
    "object_class_label": "Austenitic Stainless Steels",
    "object_class_group": "Stainless Steel Classification",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": "normally",
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "AlloyScope: 300 Series stainless steels"
    },
    "confidence": 0.9,
    "remarks": [
      "Complements the alloy→structure relation by capturing where the structure is typically present."
    ]
  },
  {
    "relation_id": "RelR_c426520a3c91",
    "relation_name": "occurs_in",
    "rel_desc": "Ferritic structure occurs as one phase within duplex stainless steels.",
    "rel_hint_type": "occurrence",
    "canonical_rel_name": "TBD",
    "canonical_rel_desc": "",
    "rel_cls": "TBD",
    "rel_cls_group": "TBD",
    "subject_entity_name": "ferritic",
    "object_entity_name": "duplex stainless steel",
    "subject_class_label": "Ferritic Structure",
    "subject_class_group": "Steel Metallurgy",
    "object_class_label": "Corrosion-Resistant Alloys",
    "object_class_group": "Corrosion-Resistant Metals and Alloys",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "StructureContext: part of mixed austenitic-ferritic phase balance"
    },
    "confidence": 0.86,
    "remarks": [
      "Redundant with the duplex→ferritic structural relation but captures the inverse perspective (where ferritic is found)."
    ]
  },
  {
    "relation_id": "RelR_7c9bc782fce9",
    "relation_name": "occurs_in",
    "rel_desc": "Austenitic structure occurs as one phase within duplex stainless steels.",
    "rel_hint_type": "occurrence",
    "canonical_rel_name": "TBD",
    "canonical_rel_desc": "",
    "rel_cls": "TBD",
    "rel_cls_group": "TBD",
    "subject_entity_name": "austenitic",
    "object_entity_name": "duplex stainless steel",
    "subject_class_label": "Austenitic Structure",
    "subject_class_group": "Steel Metallurgy",
    "object_class_label": "Corrosion-Resistant Alloys",
    "object_class_group": "Corrosion-Resistant Metals and Alloys",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "StructureContext: part of mixed austenitic-ferritic phase balance"
    },
    "confidence": 0.86,
    "remarks": [
      "Inverse perspective of the duplex→austenitic structural relation, included for coverage of where the austenitic phase is found."
    ]
  },
  {
    "relation_id": "RelR_caa4eec09380",
    "relation_name": "occurs_in",
    "rel_desc": "Hydrogen Induced Cracking (HIC) is described as a cracking mechanism that occurs in steels, which plausibly includes low alloy steels as a subset.",
    "rel_hint_type": "occurrence",
    "canonical_rel_name": "TBD",
    "canonical_rel_desc": "",
    "rel_cls": "TBD",
    "rel_cls_group": "TBD",
    "subject_entity_name": "Hydrogen Induced Cracking (HIC)",
    "object_entity_name": "low alloy steel",
    "subject_class_label": "Hydrogen-Induced Cracking Mechanisms",
    "subject_class_group": "Environmental Cracking Mechanisms",
    "object_class_label": "High-Temperature Steels",
    "object_class_group": "Steel Metallurgy and Degradation",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": "on different planes in the metal / steels; may connect to the metal surface",
      "OperationalConstraint": "no externally applied stress is needed for formation of HIC",
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": "because of internal pressure resulting from the accumulation of hydrogen",
      "LogicalMarker": null,
      "OtherQualifier": "CrackMechanism: stepwise internal cracks that connect adjacent hydrogen blisters; LinkMechanism: transgranular plastic shear"
    },
    "confidence": 0.38,
    "remarks": [
      "Relation added mainly to capture that HIC is a cracking mechanism relevant to steels, with low alloy steel treated as a representative steel family. Semantics somewhat generic; confidence reduced because the text does not explicitly name low alloy steels as HIC-susceptible."
    ]
  },
  {
    "relation_id": "RelR_704fe359a26f",
    "relation_name": "occurs_in",
    "rel_desc": "Graphitization occurs in low alloy C-Mo steels containing up to 1% Mo.",
    "rel_hint_type": "occurrence",
    "canonical_rel_name": "TBD",
    "canonical_rel_desc": "",
    "rel_cls": "TBD",
    "rel_cls_group": "TBD",
    "subject_entity_name": "graphitization",
    "object_entity_name": "low alloy C-Mo steel",
    "subject_class_label": "Graphitization (Process)",
    "subject_class_group": "Steel Metallurgy and Degradation",
    "object_class_label": "Graphitization-Susceptible Steels",
    "object_class_group": "Steel Metallurgy and Degradation",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": "with up to 1% Mo",
      "UncertaintyQualifier": null,
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "ObservationContext: field or service experience"
    },
    "confidence": 0.88,
    "remarks": []
  },
  {
    "relation_id": "RelR_81f81efb1983",
    "relation_name": "occurs_in",
    "rel_desc": "Graphite nodules are present in carbon steels as products of carbide decomposition at elevated temperatures.",
    "rel_hint_type": "occurrence",
    "canonical_rel_name": "TBD",
    "canonical_rel_desc": "",
    "rel_cls": "TBD",
    "rel_cls_group": "TBD",
    "subject_entity_name": "graphite nodules",
    "object_entity_name": "carbon steel",
    "subject_class_label": "Graphite Nodules (Product)",
    "subject_class_group": "Steel Metallurgy and Degradation",
    "object_class_label": "Graphitization-Susceptible Steels",
    "object_class_group": "Steel Metallurgy and Degradation",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": "within the steel matrix",
      "OperationalConstraint": "at elevated temperatures",
      "ConditionExpression": null,
      "UncertaintyQualifier": "may decompose into",
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "Origin: decomposition of carbide phases"
    },
    "confidence": 0.7,
    "remarks": [
      "Subjective mapping of the pronoun “these steels” to carbon steels; 0.5Mo steels are handled in a separate relation."
    ]
  },
  {
    "relation_id": "RelR_c686532b051c",
    "relation_name": "occurs_in",
    "rel_desc": "Graphite nodules can also occur in 0.5Mo steels under elevated temperature conditions.",
    "rel_hint_type": "occurrence",
    "canonical_rel_name": "TBD",
    "canonical_rel_desc": "",
    "rel_cls": "TBD",
    "rel_cls_group": "TBD",
    "subject_entity_name": "graphite nodules",
    "object_entity_name": "0.5Mo steel",
    "subject_class_label": "Graphite Nodules (Product)",
    "subject_class_group": "Steel Metallurgy and Degradation",
    "object_class_label": "Graphitization-Susceptible Steels",
    "object_class_group": "Steel Metallurgy and Degradation",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": "within the steel",
      "OperationalConstraint": "at elevated temperatures",
      "ConditionExpression": null,
      "UncertaintyQualifier": "may decompose into",
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "Origin: carbide phase decomposition associated with graphitization"
    },
    "confidence": 0.65,
    "remarks": [
      "Moderate uncertainty because the pronoun could be read as all previously mentioned affected steels."
    ]
  }
]

--------------------------------
OUTPUT
--------------------------------

Return ONLY a JSON ARRAY of function calls, e.g.:

[
  {
    "function": "set_rel_schema",
    "args": { ... }
  },
  {
    "function": "modify_relation",
    "args": { ... }
  }
]

- If the cluster is already perfect (rare), you MAY return [].
- Every call MUST include a "justification".
- Use "remark" to flag any issues or uncertainties that are outside the scope of these functions.
