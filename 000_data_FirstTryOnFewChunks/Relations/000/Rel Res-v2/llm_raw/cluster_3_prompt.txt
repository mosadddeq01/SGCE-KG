
You are a very proactive RELATION-RESOLUTION assistant.

You are given a CLUSTER of relation INSTANCES from a context-enriched technical KG.
Each relation instance already connects specific subject and object entities, and has:

- relation_id
- relation_name        (raw, from Relation Recognition)
- rel_desc             (instance-level description)
- rel_hint_type        (short free-form hint)
- canonical_rel_name   (TBD or already set)
- canonical_rel_desc   (TBD or already set)
- rel_cls              (TBD or already set)
- rel_cls_group        (TBD or already set)
- subject_entity_name, object_entity_name
- subject_class_label, subject_class_group
- object_class_label, object_class_group
- qualifiers (temporal, spatial, etc.)
- confidence, remarks, etc.

IMPORTANT:
- SUBJECT and OBJECT are already resolved entities. You MUST NOT change them.
- We NEVER delete relation instances. We only enrich them with schema (canonical name, class, group).
- relation_name and rel_desc are EVIDENCE and should normally NOT be overwritten.
- canonical_rel_name is the normalized predicate that will be used as the KG edge label.
- rel_cls and rel_cls_group give a two-layer schema for relations:
    relation_instance → canonical_rel_name → rel_cls → rel_cls_group

Your job for THIS CLUSTER:
1) Group semantically equivalent or near-equivalent relation instances.
2) For each group, assign or refine:
   - canonical_rel_name   (normalized predicate)
   - canonical_rel_desc   (reusable description of that predicate)
   - rel_cls              (e.g., "structure_relation", "corrosion_resistance_relation")
   - rel_cls_group        (broad group like COMPOSITION, CAUSALITY, IDENTITY, TEMPORALITY,
                           SPATIALITY, AGENCY, INTERACTION, ASSOCIATION, MODIFICATION, etc.)
3) Be conservative with overwriting existing canonical info:
   - If fields are "TBD", you SHOULD set them.
   - If fields are already set but clearly wrong or too narrow/broad, you MAY refine them.

We will apply your instructions by executing function calls on the relation objects.
You MUST return an ordered JSON ARRAY of function calls with the following functions ONLY:

--------------------------------
AVAILABLE FUNCTIONS
--------------------------------

1) set_rel_schema
   Use this to ASSIGN or UPDATE schema fields for one or more relation instances,
   especially when canonical_rel_name / rel_cls / rel_cls_group are currently "TBD".

   args = {
     "relation_ids": [<relation_id>...],            # REQUIRED, at least 1
     "canonical_rel_name": <string or null>,        # normalized predicate used for KG edge
     "canonical_rel_desc": <string or null>,        # reusable description of this predicate
     "rel_cls": <string or null>,                   # relation class (e.g., "structure_relation")
     "rel_cls_group": <string or null>,             # broad group (e.g., "COMPOSITION")
     "justification": <string>,                     # REQUIRED: why this grouping & naming makes sense
     "remark": <string or null>,                    # optional: human-facing notes
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - canonical_rel_name should be a short predicate-like phrase, useful as an edge label.
   - canonical_rel_desc should generalize across all relation_ids you include in this call.
   - rel_cls is a more abstract class for similar predicates (e.g., grouping several canonical names).
   - rel_cls_group is even more abstract (COMPOSITION, CAUSALITY, etc.).

2) modify_relation
   Use this to REFINE or CORRECT schema for one or more relation instances, or to attach remarks.
   For example, adjusting rel_cls_group, tweaking canonical_rel_desc, or rarely correcting a bad relation_name.

   args = {
     "relation_ids": [<relation_id>...],            # REQUIRED, at least 1
     "canonical_rel_name": <string or null>,        # OPTIONAL: new canonical name
     "canonical_rel_desc": <string or null>,        # OPTIONAL: new canonical description
     "rel_cls": <string or null>,                   # OPTIONAL: new relation class
     "rel_cls_group": <string or null>,             # OPTIONAL: new broad group
     "new_relation_name": <string or null>,         # OPTIONAL: ONLY if absolutely necessary
     "original_relation_name": <string or null>,    # REQUIRED if you change relation_name
     "justification": <string>,                     # REQUIRED: why this modification is needed
     "remark": <string or null>,                    # optional: notes / flags
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - You should RARELY change relation_name (raw). Only do so if it is clearly malformed,
     misleading, or not a real predicate. In that case, you MUST provide original_relation_name
     and explain why the change is necessary.
   - Use modify_relation to refine or correct previously set canonical/schema fields.

--------------------------------
GENERAL GUIDANCE
--------------------------------

- THINK CLUSTER-WIDE:
  - Prefer grouping multiple relation_ids in a single set_rel_schema call when they clearly
    share the same canonical_rel_name / rel_cls / rel_cls_group.
  - If some instances are outliers, you can give them different canonical_rel_name or rel_cls.

- CANONICAL_REL_NAME:
  - Short, predicate-style, reusable across many entity pairs (e.g., "occurs_in", "resists",
    "has_metallurgical_structure", "is_subtype_of").
  - DO NOT include qualifiers like "at high temperature": qualifiers live in the qualifiers dict.
  - This is what we will put on the KG edge as the predicate.

- CANONICAL_REL_DESC:
  - 1–2 sentences describing the general meaning of the canonical_rel_name, independent
    of specific entities in this cluster.

- REL_CLS:
  - A more abstract class that groups semantically similar canonical predicates.
    For example, "has_metallurgical_structure", "has_phase", "has_microstructure_component"
    might all belong to rel_cls = "structure_relation".

- REL_CLS_GROUP:
  - A very broad, high-level category, open-ended but typically one of:
    COMPOSITION, CAUSALITY, IDENTITY, TEMPORALITY, SPATIALITY,
    AGENCY, INTERACTION, ASSOCIATION, MODIFICATION, USAGE, REQUIREMENT, etc.
  - This list is illustrative, NOT exhaustive. You may use other sensible names.

- DO NOT:
  - Do NOT delete relations.
  - Do NOT change subject or object.
  - Do NOT move qualifiers to nodes; qualifiers stay with the relation instances.
  - Do NOT be passive. If there is semantic structure to expose, you MUST propose schema.

--------------------------------
INPUT RELATIONS (CLUSTER)
--------------------------------

Below is the JSON array of relation instances in this cluster:

[
  {
    "relation_id": "RelR_338e547f321f",
    "relation_name": "alters_microstructure_of",
    "rel_desc": "Graphitization alters the microstructure of carbon steels after long-term operation, degrading their mechanical properties.",
    "rel_hint_type": "structural_change",
    "canonical_rel_name": "TBD",
    "canonical_rel_desc": "",
    "rel_cls": "TBD",
    "rel_cls_group": "TBD",
    "subject_entity_name": "graphitization",
    "object_entity_name": "carbon steel",
    "subject_class_label": "Graphitization (Process)",
    "subject_class_group": "Steel Metallurgy and Degradation",
    "object_class_label": "Graphitization-Susceptible Steels",
    "object_class_group": "Steel Metallurgy and Degradation",
    "qualifiers": {
      "TemporalQualifier": "after long-term operation",
      "SpatialQualifier": null,
      "OperationalConstraint": "operation in the 800°F to 1100°F (427°C to 593°C) range",
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": "that may cause a loss in strength, ductility, and/or creep resistance",
      "LogicalMarker": null,
      "OtherQualifier": "DamageType: mechanical property degradation"
    },
    "confidence": 0.9,
    "remarks": []
  },
  {
    "relation_id": "RelR_29b3c1c25656",
    "relation_name": "alters_microstructure_of",
    "rel_desc": "Graphitization alters the microstructure of 0.5Mo steels during long-term high-temperature operation.",
    "rel_hint_type": "structural_change",
    "canonical_rel_name": "TBD",
    "canonical_rel_desc": "",
    "rel_cls": "TBD",
    "rel_cls_group": "TBD",
    "subject_entity_name": "graphitization",
    "object_entity_name": "0.5Mo steel",
    "subject_class_label": "Graphitization (Process)",
    "subject_class_group": "Steel Metallurgy and Degradation",
    "object_class_label": "Graphitization-Susceptible Steels",
    "object_class_group": "Steel Metallurgy and Degradation",
    "qualifiers": {
      "TemporalQualifier": "after long-term operation",
      "SpatialQualifier": null,
      "OperationalConstraint": "operation in the 800°F to 1100°F (427°C to 593°C) range",
      "ConditionExpression": null,
      "UncertaintyQualifier": "may cause",
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "DamageType: loss in strength, ductility, and/or creep resistance"
    },
    "confidence": 0.9,
    "remarks": []
  },
  {
    "relation_id": "RelR_a45fb4ca81de",
    "relation_name": "produces",
    "rel_desc": "Graphitization corresponds to decomposition of carbide phases into graphite nodules, effectively producing graphite nodules in the steel.",
    "rel_hint_type": "transformation",
    "canonical_rel_name": "TBD",
    "canonical_rel_desc": "",
    "rel_cls": "TBD",
    "rel_cls_group": "TBD",
    "subject_entity_name": "graphitization",
    "object_entity_name": "graphite nodules",
    "subject_class_label": "Graphitization (Process)",
    "subject_class_group": "Steel Metallurgy and Degradation",
    "object_class_label": "Graphite Nodules (Product)",
    "object_class_group": "Steel Metallurgy and Degradation",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": "in these steels",
      "OperationalConstraint": "at elevated temperatures",
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": "decompose into",
      "LogicalMarker": null,
      "OtherQualifier": null
    },
    "confidence": 0.82,
    "remarks": [
      "Carbide phases are not an explicit entity; relation framed between graphitization and graphite nodules to preserve transformation context."
    ]
  }
]

--------------------------------
OUTPUT
--------------------------------

Return ONLY a JSON ARRAY of function calls, e.g.:

[
  {
    "function": "set_rel_schema",
    "args": { ... }
  },
  {
    "function": "modify_relation",
    "args": { ... }
  }
]

- If the cluster is already perfect (rare), you MAY return [].
- Every call MUST include a "justification".
- Use "remark" to flag any issues or uncertainties that are outside the scope of these functions.
