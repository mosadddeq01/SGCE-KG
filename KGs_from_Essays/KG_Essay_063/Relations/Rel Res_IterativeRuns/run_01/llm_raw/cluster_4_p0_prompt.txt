
You are a very proactive RELATION-RESOLUTION assistant, and an expert in knowledge graphs (KGs) and schema (ontology) design.

You are given a CLUSTER of relation INSTANCES from a context-enriched technical KG.
Each relation instance already connects specific subject and object entities, and has:

- relation_id
- relation_name        (raw, from Relation Recognition; may be noisy)
- rel_desc             (instance-level description; may be verbose)
- rel_hint_type        (short free-form hint; may be noisy)
- canonical_rel_name   (often "TBD" initially)
- canonical_rel_desc   (often empty initially)
- rel_cls              (often "TBD" initially)
- rel_cls_group        (often "TBD" initially)
- subject_entity_name, object_entity_name
- subject_class_label, subject_class_group
- object_class_label, object_class_group
- qualifiers (temporal, spatial, etc.)
- confidence, remarks, etc.

IMPORTANT CONTEXT ABOUT THE PIPELINE
------------------------------------
- ALL these fields (especially relation_name, rel_desc, and rel_hint_type) were
  generated by previous LLM stages. They are **approximate** and may be:
    - awkward in wording,
    - too specific,
    - too generic,
    - or slightly wrong.
- This step follows a "generate first, refine later" philosophy.
  Your job is to **refine, disambiguate, normalize, and improve human readability as a KG expert**, not to copy the wording blindly.
- Use upstream fields (especially relation_name, rel_desc, and rel_hint_type) as **semantic hints**, not as final label candidates AT ALL!

MULTI-RUN / REFINEMENT INSTRUCTIONS (READ ONLY WHEN THE FOLLOWING FIELDS ARE ALREADY FILLED: canonical_rel_name, canonical_rel_desc, rel_cls, rel_cls_group)
- Only read/apply the following guidance when at least one of the fields above is NOT "TBD" for relations in this chunk. It means we are in a refinement run.
- Do NOT be passive: if any pre-filled value is inconsistent, ambiguous, or improvable, you MUST propose a correction (use modify_rel_schema) with a concise justification.
- Only return [] if there is extremely strong evidence that no change is required (this is rare).
- This is an iterative process — act now with well-justified corrections using modify_rel_schema (include a short justification), rather than deferring small but meaningful fixes.
- This step will be repeated in later iterations; reasonable but imperfect changes can be corrected later. It is worse to miss a necessary change than to propose a well-justified change that might be slightly adjusted later.


ABOUT CLUSTERS (CRITICAL)
-------------------------
- The cluster you see is produced automatically from embeddings.
- The cluster is **only suggestive**, NOT a hard class:
    - It may contain multiple different canonical relations.
    - It may contain multiple different relation classes.
    - It may contain multiple different relation class groups.
- Your task is **NOT**:
    - "Find ONE canonical_rel_name that covers (almost) all relations in the cluster."
    - "Force all relations in the cluster into the same rel_cls or rel_cls_group."
- Your task **IS**:
    - For EACH relation instance, decide what canonical_rel_name, rel_cls,
      and rel_cls_group are appropriate (especially from the lens of a KG and Schema expert).
    - If some instances do NOT naturally share semantics, assign them different
      canonical_rel_name / rel_cls / rel_cls_group, even though they are
      in the same cluster.
    - If some other instances in the cluster naturally share exactly the same
      semantics, group them together in the same function call.

CRUCIAL DISTINCTION (SCOPE)
---------------------------
We use a 3-layer abstraction for relations:

1) canonical_rel_name
   - Fine-grained, predicate-level.
   - Groups relations that use essentially the SAME predicate meaning and direction.
   - This is the predicate that will be used as the edge label in the KG.
   - Examples: "occurs_in", "resists", "provides_resistance_to", "is_subtype_of",
     "has_metallurgical_structure", "grouped_with".

2) rel_cls
   - A broader relation CLASS that may cover multiple canonical_rel_name values.
   - Think of this as a family of similar predicates.
   - Examples (illustrative): "alloying_element_relation", "microstructure_relation",
     "hierarchy_relation", "corrosion_resistance_relation", "document_series_relation".
   - IMPORTANT: rel_cls should be more specific than broad groups, but more general
     than a single canonical_rel_name.

3) rel_cls_group
   - Very broad semantic DIMENSIONS:
       COMPOSITION, CAUSALITY, IDENTITY, TEMPORALITY, SPATIALITY, AGENCY,
       ASSOCIATION, MODIFICATION, USAGE, REQUIREMENT, etc.
   - This list is illustrative, NOT exhaustive.
   - Example:
       canonical_rel_name: "contains_alloying_element"
       rel_cls:            "alloying_element_relation"
       rel_cls_group:      "COMPOSITION"

RELATION-BY-RELATION THINKING (SUPER IMPORTANT)
-----------------------------------------------
For every relation instance in the cluster, conceptually ask:

1) What is the **best canonical predicate** (canonical_rel_name) for THIS instance,
   ignoring awkward wording in relation_name / rel_hint_type?
2) Which broader **relation class** (rel_cls) best describes this connection?
3) Which **rel_cls_group** (COMPOSITION, CAUSALITY, etc.) does it belong to?

Then:
- If you see other instances in the cluster with the **same semantics**, you may
  include them in the same function call (same canonical_rel_name / rel_cls / rel_cls_group).
- Do NOT try to find one label that covers ALL instances in the cluster.

NOISY HINTS AND HOW TO USE THEM
-------------------------------
- relation_name, rel_desc, rel_hint_type are hints, not perfect labels.
- Examples of bad patterns that you should NOT copy directly:
    - rel_hint_type = "co-classification" → this is awkward wording; interpret it
      as "these things are grouped together as co-equal categories" and choose
      a better canonical name / class (e.g., "grouped_with" with rel_cls
      "coequal_category_relation", rel_cls_group "ASSOCIATION" or "IDENTITY").
    - rel_hint_type = "causal" → this suggests rel_cls_group "CAUSALITY",
      but is NOT a good canonical_rel_name or rel_cls by itself.
- Also avoid redundant patterns like:
    - rel_cls = "composition_relation" when rel_cls_group = "COMPOSITION".
      In that case, choose a more specific rel_cls label, e.g.,
      "alloying_element_relation" or "microstructure_relation".

DEDUPLICATION & NORMALIZATION
-----------------------------
- Within a cluster, if you see multiple predicate variants that are semantically
  the same (e.g., "has_subtype", "is_subtype_of"), you MUST normalize them
  to **one** canonical_rel_name and apply it consistently:
    - For hierarchical relations, prefer a single consistent style, e.g., "is_subtype_of".
- Avoid creating trivial variants that only differ in small wording:
    - Do NOT keep both "provides_resistance_to" and "improves_resistance_to"
      if they are used identically for the same semantic link; pick one.
- Avoid rel_cls that simply repeats rel_cls_group with "_relation" added
  (e.g., "composition_relation" when rel_cls_group is "COMPOSITION").

WHAT YOU NEVER CHANGE
----------------------
- SUBJECT and OBJECT entities are fixed; you MUST NOT change them.
- You NEVER delete relation instances.
- You NEVER move qualifiers from relations onto nodes; qualifiers stay on the
  relation instance.

YOUR FUNCTION VOCABULARY
------------------------
You must return an ordered JSON ARRAY of function calls using ONLY:

1) set_canonical_rel
2) set_rel_cls
3) set_rel_cls_group
4) modify_rel_schema
5) add_rel_remark

Think RELATION-BY-RELATION first, and only group multiple relation_ids into the
same function call when you are genuinely sure they share the same semantics.

--------------------------------
FUNCTION DEFINITIONS
--------------------------------

1) set_canonical_rel
   Use this when you want to SET or ALIGN canonical_rel_name / canonical_rel_desc
   for one or more relation instances (especially when values are "TBD").

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "canonical_rel_name": <string>,           # REQUIRED, normalized predicate for KG edge
     "canonical_rel_desc": <string or null>,   # OPTIONAL, reusable description of this predicate
     "justification": <string>,                # REQUIRED: why these instances share this canonical predicate
     "remark": <string or null>,               # optional human-facing notes
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - canonical_rel_name should be a short predicate-style phrase, e.g. "occurs_in",
     "resists", "provides_resistance_to", "is_subtype_of", "has_metallurgical_structure".
   - Do NOT include qualifiers (e.g., "at high temperature") here.
   - Use this on relatively TIGHT groups of semantically equivalent predicates.
   - It is perfectly fine to call set_canonical_rel with a **single** relation_id
     when others in the cluster do not share the semantics.


2) set_rel_cls
   Use this when you want to SET or ALIGN rel_cls for one or more instances,
   grouping them into a broader relation class (family).

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "rel_cls": <string>,                      # REQUIRED: class name (e.g., "structure_relation")
     "justification": <string>,                # REQUIRED: why these instances belong to this class
     "remark": <string or null>,               # optional notes
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - A rel_cls usually covers MULTIPLE canonical_rel_name values, not just one.
   - Think of rel_cls as a conceptual family: e.g. "alloying_element_relation",
     "microstructure_relation", "document_series_relation".
   - Do NOT simply repeat rel_cls_group (e.g. avoid "composition_relation" when
     rel_cls_group is "COMPOSITION") unless there is truly no more specific
     and meaningful class you can provide.


3) set_rel_cls_group
   Use this when you want to SET or ALIGN rel_cls_group for one or more instances
   (or their classes), using a very broad semantic category.

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "rel_cls_group": <string>,                # REQUIRED: broad group (e.g., "COMPOSITION")
     "justification": <string>,                # REQUIRED: why this group fits
     "remark": <string or null>,               # optional notes
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - rel_cls_group is broad and somewhat orthogonal.
   - Typical groups: COMPOSITION, CAUSALITY, IDENTITY, TEMPORALITY, SPATIALITY,
     AGENCY, INTERACTION, ASSOCIATION, MODIFICATION, USAGE, REQUIREMENT, etc.
   - General hints like rel_hint_type="causal" are better mapped to rel_cls_group
     (CAUSALITY) than to canonical_rel_name.


4) modify_rel_schema
   Use this to REFINE or CORRECT existing schema fields for one or more relations
   (canonical_rel_name / canonical_rel_desc / rel_cls / rel_cls_group).

   args = {
     "relation_ids": [<relation_id>...],            # REQUIRED, at least 1
     "canonical_rel_name": <string or null>,        # OPTIONAL: new canonical name
     "canonical_rel_desc": <string or null>,        # OPTIONAL: new canonical description
     "rel_cls": <string or null>,                   # OPTIONAL: new relation class
     "rel_cls_group": <string or null>,             # OPTIONAL: new broad group
     "justification": <string>,                     # REQUIRED: why this modification is needed
     "remark": <string or null>,                    # optional notes / flags
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - Do NOT be passive: if any pre-filled value is inconsistent, ambiguous, or improvable, you MUST propose a correction using modify_rel_schema.
   - This is iterative: make well-justified corrections now (include a short justification); later runs may further refine them. 
   - It is worse to miss a necessary change than to propose a justified change that might be slightly adjusted later.
   - You MUST NOT try to change (poor) relation_names. As long as the canonical_rel_name, rel_cls, and rel_cls_group are fine, we are good. 
     But if they need correction, YOU MUST use modify_rel_schema to correct them. We will not use raw relation name in the KG. 
   - You MAY use this to normalize even minor variants (e.g., consolidate "has_subtype"
   and "is_subtype_of" to "is_subtype_of") when needed. We want consistent schema.
   


5) add_rel_remark
   Use this when you ONLY want to attach a human-facing remark / caveat / TODO
   without changing any schema fields.

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "remark": <string>,                        # REQUIRED: the remark text
     "justification": <string>,                # REQUIRED: why this remark is useful
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - Use this for issues outside scope (e.g., upstream entity resolution suspicion), or
     to flag ambiguous or borderline cases for later human review.

--------------------------------
INPUT RELATIONS (THIS CHUNK)
--------------------------------

Below is the JSON array of relation instances in THIS PART of a cluster
(we split very large clusters into smaller chunks just to keep the prompt size manageable):

[
  {
    "relation_id": "RelR_6131678e67af",
    "relation_name": "occurs_in",
    "rel_desc": "Social and political change is said to occur within societies.",
    "rel_hint_type": "location",
    "canonical_rel_name": "occurs_in",
    "canonical_rel_desc": "Indicates that an event, process, or phenomenon takes place within a specified spatial or societal context.",
    "rel_cls": "event_or_process_location_relation",
    "rel_cls_group": "SPATIALITY",
    "subject_entity_name": "social and political change",
    "object_entity_name": "societies",
    "subject_class_label": "Socio-Political Transformation",
    "subject_class_group": "Sociopolitical Systems and Change",
    "object_class_label": "Global Sociopolitical Context",
    "object_class_group": "Sociopolitical Systems and Change",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": "in societies around the world",
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": null
    },
    "confidence": 0.9,
    "remarks": []
  },
  {
    "relation_id": "RelR_e6222803654a",
    "relation_name": "occurs_in",
    "rel_desc": "The strike by pyramid workers took place in ancient Egypt.",
    "rel_hint_type": "spatial",
    "canonical_rel_name": "occurs_in",
    "canonical_rel_desc": "An event or process takes place within a specified geographic, political, or administrative region.",
    "rel_cls": "spatial_location_relation",
    "rel_cls_group": "SPATIALITY",
    "subject_entity_name": "strike by pyramid workers",
    "object_entity_name": "ancient Egypt",
    "subject_class_label": "Pyramid Construction and Labor Strike (Ancient Egypt)",
    "subject_class_group": "Historical Labor Protests",
    "object_class_label": "Ancient Egypt",
    "object_class_group": "Historical Labor Protests",
    "qualifiers": {
      "TemporalQualifier": "ancient times",
      "SpatialQualifier": "ancient Egypt",
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": "reportedly",
      "CausalHint": null,
      "LogicalMarker": "where",
      "OtherQualifier": null
    },
    "confidence": 0.97,
    "remarks": []
  },
  {
    "relation_id": "RelR_4c1e78b7fcb1",
    "relation_name": "located_in",
    "rel_desc": "The Egyptian pyramids are situated in ancient Egypt.",
    "rel_hint_type": "spatial",
    "canonical_rel_name": "located_in",
    "canonical_rel_desc": "An entity or object is geographically or spatially situated within a specified place or region.",
    "rel_cls": "spatial_location_relation",
    "rel_cls_group": "SPATIALITY",
    "subject_entity_name": "ancient Egypt",
    "object_entity_name": "Egyptian pyramids",
    "subject_class_label": "Ancient Egypt",
    "subject_class_group": "Historical Labor Protests",
    "object_class_label": "Pyramid Construction and Labor Strike (Ancient Egypt)",
    "object_class_group": "Historical Labor Protests",
    "qualifiers": {
      "TemporalQualifier": "ancient times",
      "SpatialQualifier": "ancient Egypt",
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": "reportedly",
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": null
    },
    "confidence": 0.96,
    "remarks": []
  },
  {
    "relation_id": "RelR_989b8999b30f",
    "relation_name": "enacted_in",
    "rel_desc": "The landmark civil rights legislation of the 1960s was enacted in the United States.",
    "rel_hint_type": "spatial",
    "canonical_rel_name": "occurs_in",
    "canonical_rel_desc": "Links an event or process to the geographic or political area where it takes place or is enacted.",
    "rel_cls": "event_location_relation",
    "rel_cls_group": "SPATIALITY",
    "subject_entity_name": "landmark civil rights legislation in the 1960s",
    "object_entity_name": "United States",
    "subject_class_label": "US Civil Rights Era Developments",
    "subject_class_group": "US Civil Rights Movement & Era",
    "object_class_label": "Sovereign Countries Mentioned",
    "object_class_group": "Geopolitical Entities (Countries)",
    "qualifiers": {
      "TemporalQualifier": "in the 1960s",
      "SpatialQualifier": "United States",
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": "implied, not explicitly named in clause",
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "LegalContext: civil rights laws"
    },
    "confidence": 0.9,
    "remarks": [
      "Spatial link inferred from context rather than explicit country name in same clause.",
      "Spatial link inferred from context rather than explicit country name in same clause."
    ]
  },
  {
    "relation_id": "RelR_6e8abada3154",
    "relation_name": "occurs_in",
    "rel_desc": "The civil rights movement took place in the United States.",
    "rel_hint_type": "spatial",
    "canonical_rel_name": "occurs_in",
    "canonical_rel_desc": "Links an event or process to the geographic or political area where it takes place or is enacted.",
    "rel_cls": "event_location_relation",
    "rel_cls_group": "SPATIALITY",
    "subject_entity_name": "civil rights movement in the United States",
    "object_entity_name": "United States",
    "subject_class_label": "US Civil Rights Era Developments",
    "subject_class_group": "US Civil Rights Movement & Era",
    "object_class_label": "Sovereign Countries Mentioned",
    "object_class_group": "Geopolitical Entities (Countries)",
    "qualifiers": {
      "TemporalQualifier": "primarily mid-20th century",
      "SpatialQualifier": "United States",
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": null
    },
    "confidence": 1.0,
    "remarks": []
  },
  {
    "relation_id": "RelR_7830c458d504",
    "relation_name": "occurs_in",
    "rel_desc": "The initial protests took place in Tunisia.",
    "rel_hint_type": "spatial",
    "canonical_rel_name": "occurs_in",
    "canonical_rel_desc": "An event or process takes place within a specified geographic, political, or administrative region.",
    "rel_cls": "spatial_location_relation",
    "rel_cls_group": "SPATIALITY",
    "subject_entity_name": "protests in Tunisia",
    "object_entity_name": "Tunisia",
    "subject_class_label": "Arab Spring Core Events",
    "subject_class_group": "Arab Spring and Its Context",
    "object_class_label": "Arab Spring Regions",
    "object_class_group": "Arab Spring and Its Context",
    "qualifiers": {
      "TemporalQualifier": "2010",
      "SpatialQualifier": "Tunisia",
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": null
    },
    "confidence": 1.0,
    "remarks": []
  },
  {
    "relation_id": "RelR_9beb6ea72b08",
    "relation_name": "starts_in",
    "rel_desc": "The Arab Spring started in the year 2010.",
    "rel_hint_type": "temporal",
    "canonical_rel_name": "starts_in_time",
    "canonical_rel_desc": "Indicates the time point or time period when an event, process, or described history begins.",
    "rel_cls": "event_onset_relation",
    "rel_cls_group": "TEMPORALITY",
    "subject_entity_name": "Arab Spring",
    "object_entity_name": "2010",
    "subject_class_label": "Arab Spring Core Events",
    "subject_class_group": "Arab Spring and Its Context",
    "object_class_label": "Arab Spring Onset Year 2010",
    "object_class_group": "Arab Spring and Its Context",
    "qualifiers": {
      "TemporalQualifier": "2010",
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": "began",
      "LogicalMarker": null,
      "OtherQualifier": null
    },
    "confidence": 1.0,
    "remarks": []
  },
  {
    "relation_id": "RelR_8993b154525b",
    "relation_name": "occurs_in",
    "rel_desc": "The Arab Spring spread across the Middle East and North Africa region.",
    "rel_hint_type": "spatial",
    "canonical_rel_name": "occurs_in",
    "canonical_rel_desc": "An event or process takes place within a specified geographic, political, or administrative region.",
    "rel_cls": "spatial_location_relation",
    "rel_cls_group": "SPATIALITY",
    "subject_entity_name": "Arab Spring",
    "object_entity_name": "Middle East and North Africa (MENA)",
    "subject_class_label": "Arab Spring Core Events",
    "subject_class_group": "Arab Spring and Its Context",
    "object_class_label": "Arab Spring Regions",
    "object_class_group": "Arab Spring and Its Context",
    "qualifiers": {
      "TemporalQualifier": "from 2010 onward during Arab Spring",
      "SpatialQualifier": "Middle East and North Africa (MENA)",
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": "spread across",
      "LogicalMarker": "and",
      "OtherQualifier": null
    },
    "confidence": 0.98,
    "remarks": [
      "MENA entity used to capture combined regional reference.",
      "MENA entity used to capture combined regional reference."
    ]
  },
  {
    "relation_id": "RelR_766a969e0e97",
    "relation_name": "occurs_in",
    "rel_desc": "The Arab Spring took place in the Middle East.",
    "rel_hint_type": "spatial",
    "canonical_rel_name": "occurs_in",
    "canonical_rel_desc": "Indicates that an event, process, or phenomenon takes place within a specified spatial or societal context.",
    "rel_cls": "event_or_process_location_relation",
    "rel_cls_group": "SPATIALITY",
    "subject_entity_name": "Arab Spring",
    "object_entity_name": "Middle East",
    "subject_class_label": "Arab Spring Core Events",
    "subject_class_group": "Arab Spring and Its Context",
    "object_class_label": "Arab Spring Regions",
    "object_class_group": "Arab Spring and Its Context",
    "qualifiers": {
      "TemporalQualifier": "from 2010 onward",
      "SpatialQualifier": "Middle East",
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": "spread across",
      "LogicalMarker": "and",
      "OtherQualifier": null
    },
    "confidence": 0.96,
    "remarks": []
  },
  {
    "relation_id": "RelR_3b803a98cd80",
    "relation_name": "occurs_in",
    "rel_desc": "The Arab Spring took place in North Africa.",
    "rel_hint_type": "spatial",
    "canonical_rel_name": "occurs_in",
    "canonical_rel_desc": "An event or process takes place within a specified geographic, political, or administrative region.",
    "rel_cls": "spatial_location_relation",
    "rel_cls_group": "SPATIALITY",
    "subject_entity_name": "Arab Spring",
    "object_entity_name": "North Africa",
    "subject_class_label": "Arab Spring Core Events",
    "subject_class_group": "Arab Spring and Its Context",
    "object_class_label": "Arab Spring Regions",
    "object_class_group": "Arab Spring and Its Context",
    "qualifiers": {
      "TemporalQualifier": "from 2010 onward",
      "SpatialQualifier": "North Africa",
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": "spread across",
      "LogicalMarker": "and",
      "OtherQualifier": null
    },
    "confidence": 0.96,
    "remarks": []
  }
]

--------------------------------
OUTPUT
--------------------------------

Return ONLY the JSON ARRAY of function calls, e.g.:

[
  {
    "function": "set_canonical_rel",
    "args": { ... }
  },
  {
    "function": "set_rel_cls",
    "args": { ... }
  },
  ...
]

- If this chunk is already perfect (rare), you MAY return [].
- Every call MUST include a "justification".
- Use "remark" (or add_rel_remark) to flag issues or uncertainties that are outside
  the scope of these functions.
