
You are a very proactive RELATION-RESOLUTION assistant, and an expert in knowledge graphs (KGs) and schema (ontology) design.

You are given a CLUSTER of relation INSTANCES from a context-enriched technical KG.
Each relation instance already connects specific subject and object entities, and has:

- relation_id
- relation_name        (raw, from Relation Recognition; may be noisy)
- rel_desc             (instance-level description; may be verbose)
- rel_hint_type        (short free-form hint; may be noisy)
- canonical_rel_name   (often "TBD" initially)
- canonical_rel_desc   (often empty initially)
- rel_cls              (often "TBD" initially)
- rel_cls_group        (often "TBD" initially)
- subject_entity_name, object_entity_name
- subject_class_label, subject_class_group
- object_class_label, object_class_group
- qualifiers (temporal, spatial, etc.)
- confidence, remarks, etc.

IMPORTANT CONTEXT ABOUT THE PIPELINE
------------------------------------
- ALL these fields (especially relation_name, rel_desc, and rel_hint_type) were
  generated by previous LLM stages. They are **approximate** and may be:
    - awkward in wording,
    - too specific,
    - too generic,
    - or slightly wrong.
- This step follows a "generate first, refine later" philosophy.
  Your job is to **refine, disambiguate, normalize, and improve human readability as a KG expert**, not to copy the wording blindly.
- Use upstream fields (especially relation_name, rel_desc, and rel_hint_type) as **semantic hints**, not as final label candidates AT ALL!

MULTI-RUN / REFINEMENT INSTRUCTIONS (READ ONLY WHEN THE FOLLOWING FIELDS ARE ALREADY FILLED: canonical_rel_name, canonical_rel_desc, rel_cls, rel_cls_group)
- Only read/apply the following guidance when at least one of the fields above is NOT "TBD" for relations in this chunk. It means we are in a refinement run.
- Do NOT be passive: if any pre-filled value is inconsistent, ambiguous, or improvable, you MUST propose a correction (use modify_rel_schema) with a concise justification.
- Only return [] if there is extremely strong evidence that no change is required (this is rare).
- This is an iterative process — act now with well-justified corrections using modify_rel_schema (include a short justification), rather than deferring small but meaningful fixes.
- This step will be repeated in later iterations; reasonable but imperfect changes can be corrected later. It is worse to miss a necessary change than to propose a well-justified change that might be slightly adjusted later.


ABOUT CLUSTERS (CRITICAL)
-------------------------
- The cluster you see is produced automatically from embeddings.
- The cluster is **only suggestive**, NOT a hard class:
    - It may contain multiple different canonical relations.
    - It may contain multiple different relation classes.
    - It may contain multiple different relation class groups.
- Your task is **NOT**:
    - "Find ONE canonical_rel_name that covers (almost) all relations in the cluster."
    - "Force all relations in the cluster into the same rel_cls or rel_cls_group."
- Your task **IS**:
    - For EACH relation instance, decide what canonical_rel_name, rel_cls,
      and rel_cls_group are appropriate (especially from the lens of a KG and Schema expert).
    - If some instances do NOT naturally share semantics, assign them different
      canonical_rel_name / rel_cls / rel_cls_group, even though they are
      in the same cluster.
    - If some other instances in the cluster naturally share exactly the same
      semantics, group them together in the same function call.

CRUCIAL DISTINCTION (SCOPE)
---------------------------
We use a 3-layer abstraction for relations:

1) canonical_rel_name
   - Fine-grained, predicate-level.
   - Groups relations that use essentially the SAME predicate meaning and direction.
   - This is the predicate that will be used as the edge label in the KG.
   - Examples: "occurs_in", "resists", "provides_resistance_to", "is_subtype_of",
     "has_metallurgical_structure", "grouped_with".

2) rel_cls
   - A broader relation CLASS that may cover multiple canonical_rel_name values.
   - Think of this as a family of similar predicates.
   - Examples (illustrative): "alloying_element_relation", "microstructure_relation",
     "hierarchy_relation", "corrosion_resistance_relation", "document_series_relation".
   - IMPORTANT: rel_cls should be more specific than broad groups, but more general
     than a single canonical_rel_name.

3) rel_cls_group
   - Very broad semantic DIMENSIONS:
       COMPOSITION, CAUSALITY, IDENTITY, TEMPORALITY, SPATIALITY, AGENCY,
       ASSOCIATION, MODIFICATION, USAGE, REQUIREMENT, etc.
   - This list is illustrative, NOT exhaustive.
   - Example:
       canonical_rel_name: "contains_alloying_element"
       rel_cls:            "alloying_element_relation"
       rel_cls_group:      "COMPOSITION"

RELATION-BY-RELATION THINKING (SUPER IMPORTANT)
-----------------------------------------------
For every relation instance in the cluster, conceptually ask:

1) What is the **best canonical predicate** (canonical_rel_name) for THIS instance,
   ignoring awkward wording in relation_name / rel_hint_type?
2) Which broader **relation class** (rel_cls) best describes this connection?
3) Which **rel_cls_group** (COMPOSITION, CAUSALITY, etc.) does it belong to?

Then:
- If you see other instances in the cluster with the **same semantics**, you may
  include them in the same function call (same canonical_rel_name / rel_cls / rel_cls_group).
- Do NOT try to find one label that covers ALL instances in the cluster.

NOISY HINTS AND HOW TO USE THEM
-------------------------------
- relation_name, rel_desc, rel_hint_type are hints, not perfect labels.
- Examples of bad patterns that you should NOT copy directly:
    - rel_hint_type = "co-classification" → this is awkward wording; interpret it
      as "these things are grouped together as co-equal categories" and choose
      a better canonical name / class (e.g., "grouped_with" with rel_cls
      "coequal_category_relation", rel_cls_group "ASSOCIATION" or "IDENTITY").
    - rel_hint_type = "causal" → this suggests rel_cls_group "CAUSALITY",
      but is NOT a good canonical_rel_name or rel_cls by itself.
- Also avoid redundant patterns like:
    - rel_cls = "composition_relation" when rel_cls_group = "COMPOSITION".
      In that case, choose a more specific rel_cls label, e.g.,
      "alloying_element_relation" or "microstructure_relation".

DEDUPLICATION & NORMALIZATION
-----------------------------
- Within a cluster, if you see multiple predicate variants that are semantically
  the same (e.g., "has_subtype", "is_subtype_of"), you MUST normalize them
  to **one** canonical_rel_name and apply it consistently:
    - For hierarchical relations, prefer a single consistent style, e.g., "is_subtype_of".
- Avoid creating trivial variants that only differ in small wording:
    - Do NOT keep both "provides_resistance_to" and "improves_resistance_to"
      if they are used identically for the same semantic link; pick one.
- Avoid rel_cls that simply repeats rel_cls_group with "_relation" added
  (e.g., "composition_relation" when rel_cls_group is "COMPOSITION").

WHAT YOU NEVER CHANGE
----------------------
- SUBJECT and OBJECT entities are fixed; you MUST NOT change them.
- You NEVER delete relation instances.
- You NEVER move qualifiers from relations onto nodes; qualifiers stay on the
  relation instance.

YOUR FUNCTION VOCABULARY
------------------------
You must return an ordered JSON ARRAY of function calls using ONLY:

1) set_canonical_rel
2) set_rel_cls
3) set_rel_cls_group
4) modify_rel_schema
5) add_rel_remark

Think RELATION-BY-RELATION first, and only group multiple relation_ids into the
same function call when you are genuinely sure they share the same semantics.

--------------------------------
FUNCTION DEFINITIONS
--------------------------------

1) set_canonical_rel
   Use this when you want to SET or ALIGN canonical_rel_name / canonical_rel_desc
   for one or more relation instances (especially when values are "TBD").

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "canonical_rel_name": <string>,           # REQUIRED, normalized predicate for KG edge
     "canonical_rel_desc": <string or null>,   # OPTIONAL, reusable description of this predicate
     "justification": <string>,                # REQUIRED: why these instances share this canonical predicate
     "remark": <string or null>,               # optional human-facing notes
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - canonical_rel_name should be a short predicate-style phrase, e.g. "occurs_in",
     "resists", "provides_resistance_to", "is_subtype_of", "has_metallurgical_structure".
   - Do NOT include qualifiers (e.g., "at high temperature") here.
   - Use this on relatively TIGHT groups of semantically equivalent predicates.
   - It is perfectly fine to call set_canonical_rel with a **single** relation_id
     when others in the cluster do not share the semantics.


2) set_rel_cls
   Use this when you want to SET or ALIGN rel_cls for one or more instances,
   grouping them into a broader relation class (family).

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "rel_cls": <string>,                      # REQUIRED: class name (e.g., "structure_relation")
     "justification": <string>,                # REQUIRED: why these instances belong to this class
     "remark": <string or null>,               # optional notes
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - A rel_cls usually covers MULTIPLE canonical_rel_name values, not just one.
   - Think of rel_cls as a conceptual family: e.g. "alloying_element_relation",
     "microstructure_relation", "document_series_relation".
   - Do NOT simply repeat rel_cls_group (e.g. avoid "composition_relation" when
     rel_cls_group is "COMPOSITION") unless there is truly no more specific
     and meaningful class you can provide.


3) set_rel_cls_group
   Use this when you want to SET or ALIGN rel_cls_group for one or more instances
   (or their classes), using a very broad semantic category.

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "rel_cls_group": <string>,                # REQUIRED: broad group (e.g., "COMPOSITION")
     "justification": <string>,                # REQUIRED: why this group fits
     "remark": <string or null>,               # optional notes
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - rel_cls_group is broad and somewhat orthogonal.
   - Typical groups: COMPOSITION, CAUSALITY, IDENTITY, TEMPORALITY, SPATIALITY,
     AGENCY, INTERACTION, ASSOCIATION, MODIFICATION, USAGE, REQUIREMENT, etc.
   - General hints like rel_hint_type="causal" are better mapped to rel_cls_group
     (CAUSALITY) than to canonical_rel_name.


4) modify_rel_schema
   Use this to REFINE or CORRECT existing schema fields for one or more relations
   (canonical_rel_name / canonical_rel_desc / rel_cls / rel_cls_group).

   args = {
     "relation_ids": [<relation_id>...],            # REQUIRED, at least 1
     "canonical_rel_name": <string or null>,        # OPTIONAL: new canonical name
     "canonical_rel_desc": <string or null>,        # OPTIONAL: new canonical description
     "rel_cls": <string or null>,                   # OPTIONAL: new relation class
     "rel_cls_group": <string or null>,             # OPTIONAL: new broad group
     "justification": <string>,                     # REQUIRED: why this modification is needed
     "remark": <string or null>,                    # optional notes / flags
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - Do NOT be passive: if any pre-filled value is inconsistent, ambiguous, or improvable, you MUST propose a correction using modify_rel_schema.
   - This is iterative: make well-justified corrections now (include a short justification); later runs may further refine them. 
   - It is worse to miss a necessary change than to propose a justified change that might be slightly adjusted later.
   - You MUST NOT try to change (poor) relation_names. As long as the canonical_rel_name, rel_cls, and rel_cls_group are fine, we are good. 
     But if they need correction, YOU MUST use modify_rel_schema to correct them. We will not use raw relation name in the KG. 
   - You MAY use this to normalize even minor variants (e.g., consolidate "has_subtype"
   and "is_subtype_of" to "is_subtype_of") when needed. We want consistent schema.
   


5) add_rel_remark
   Use this when you ONLY want to attach a human-facing remark / caveat / TODO
   without changing any schema fields.

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "remark": <string>,                        # REQUIRED: the remark text
     "justification": <string>,                # REQUIRED: why this remark is useful
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - Use this for issues outside scope (e.g., upstream entity resolution suspicion), or
     to flag ambiguous or borderline cases for later human review.

--------------------------------
INPUT RELATIONS (THIS CHUNK)
--------------------------------

Below is the JSON array of relation instances in THIS PART of a cluster
(we split very large clusters into smaller chunks just to keep the prompt size manageable):

[
  {
    "relation_id": "RelR_ddd8b5d46713",
    "relation_name": "supports_reproduction_and_spread_of",
    "rel_desc": "Birds support the reproduction and colonization of new areas by plant species.",
    "rel_hint_type": "ecological_service",
    "canonical_rel_name": "facilitates_reproduction_and_dispersal_of",
    "canonical_rel_desc": "Indicates that the subject facilitates or supports the reproduction and spatial dispersal/colonization of the object population or species (e.g., via pollination or seed dispersal).",
    "rel_cls": "reproductive_support_relation",
    "rel_cls_group": "CAUSALITY",
    "subject_entity_name": "birds",
    "object_entity_name": "plant species",
    "subject_class_label": "Bird Biotic Components",
    "subject_class_group": "Birds as Environmental Indicators & Conservation",
    "object_class_label": "Pollination-Dependent Plant Species",
    "object_class_group": "Bird-Mediated Plant Reproduction and Regeneration",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": "new areas",
      "OperationalConstraint": null,
      "ConditionExpression": "Without birds, plant species struggle to reproduce and colonize",
      "UncertaintyQualifier": null,
      "CausalHint": "leading to",
      "LogicalMarker": "Without",
      "OtherQualifier": "ServiceType: plant reproduction and colonization"
    },
    "confidence": 0.9,
    "remarks": []
  },
  {
    "relation_id": "RelR_7b5e21c2d303",
    "relation_name": "enables_reproduction_and_spread_of",
    "rel_desc": "Seed dispersal enables plant species to reproduce and colonize new areas.",
    "rel_hint_type": "functional_dependency",
    "canonical_rel_name": "facilitates_reproduction_and_dispersal_of",
    "canonical_rel_desc": "Indicates that the subject (organism, agent, or process) functionally enables or supports both the reproductive success and spatial dispersal/colonization of the object species or population (e.g., via seed dispersal into new areas).",
    "rel_cls": "reproductive_support_relation",
    "rel_cls_group": "CAUSALITY",
    "subject_entity_name": "seed dispersal",
    "object_entity_name": "plant species",
    "subject_class_label": "Plant Reproduction and Dispersal Processes",
    "subject_class_group": "Bird-Mediated Plant Reproduction and Regeneration",
    "object_class_label": "Pollination-Dependent Plant Species",
    "object_class_group": "Bird-Mediated Plant Reproduction and Regeneration",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": "new areas",
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": "In addition to seed dispersal",
      "LogicalMarker": null,
      "OtherQualifier": "ProcessRole: plant reproduction and colonization"
    },
    "confidence": 0.86,
    "remarks": [
      "Seed dispersal is implied as the mechanism for plant reproduction and colonization.",
      "Seed dispersal is implied as the mechanism for plant reproduction and colonization.",
      "Seed dispersal is implied as the mechanism for plant reproduction and colonization.",
      "Seed dispersal is implied as the mechanism for plant reproduction and colonization."
    ]
  },
  {
    "relation_id": "RelR_50685bc9eda7",
    "relation_name": "enables_reproduction_of",
    "rel_desc": "Pollination is the process that enables reproduction in certain plant species.",
    "rel_hint_type": "functional role",
    "canonical_rel_name": "facilitates_reproduction_of",
    "canonical_rel_desc": "Indicates that the subject (organism, agent, or process) functionally enables or supports the reproductive success and population maintenance of the object species.",
    "rel_cls": "reproductive_support_relation",
    "rel_cls_group": "CAUSALITY",
    "subject_entity_name": "pollination",
    "object_entity_name": "plant species",
    "subject_class_label": "Plant Reproduction and Dispersal Processes",
    "subject_class_group": "Bird-Mediated Plant Reproduction and Regeneration",
    "object_class_label": "Pollination-Dependent Plant Species",
    "object_class_group": "Bird-Mediated Plant Reproduction and Regeneration",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": "for certain plant species",
      "UncertaintyQualifier": null,
      "CausalHint": null,
      "LogicalMarker": "for",
      "OtherQualifier": "Reproductive context: transfer of pollen"
    },
    "confidence": 0.87,
    "remarks": []
  },
  {
    "relation_id": "RelR_a4614ed123fb",
    "relation_name": "supports_reproduction_of",
    "rel_desc": "Bird pollinators support the reproduction of many plant species; without them, these plants would struggle.",
    "rel_hint_type": "dependency",
    "canonical_rel_name": "facilitates_reproduction_of",
    "canonical_rel_desc": "Indicates that the subject (organism, agent, or process) functionally enables or supports the reproductive success and population maintenance of the object species.",
    "rel_cls": "reproductive_support_relation",
    "rel_cls_group": "CAUSALITY",
    "subject_entity_name": "bird pollinators",
    "object_entity_name": "plant species",
    "subject_class_label": "Bird Pollinators",
    "subject_class_group": "Bird-Mediated Plant Reproduction and Regeneration",
    "object_class_label": "Pollination-Dependent Plant Species",
    "object_class_group": "Bird-Mediated Plant Reproduction and Regeneration",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": "in the absence of bird pollinators",
      "UncertaintyQualifier": "would struggle (modal)",
      "CausalHint": "Without bird pollinators",
      "LogicalMarker": "Without",
      "OtherQualifier": "Effect: struggle to reproduce and maintain their populations"
    },
    "confidence": 0.9,
    "remarks": []
  }
]

--------------------------------
OUTPUT
--------------------------------

Return ONLY the JSON ARRAY of function calls, e.g.:

[
  {
    "function": "set_canonical_rel",
    "args": { ... }
  },
  {
    "function": "set_rel_cls",
    "args": { ... }
  },
  ...
]

- If this chunk is already perfect (rare), you MAY return [].
- Every call MUST include a "justification".
- Use "remark" (or add_rel_remark) to flag issues or uncertainties that are outside
  the scope of these functions.
