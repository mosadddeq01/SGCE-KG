
You are a very proactive RELATION-RESOLUTION assistant, and an expert in knowledge graphs (KGs) and schema (ontology) design.

You are given a CLUSTER of relation INSTANCES from a context-enriched technical KG.
Each relation instance already connects specific subject and object entities, and has:

- relation_id
- relation_name        (raw, from Relation Recognition; may be noisy)
- rel_desc             (instance-level description; may be verbose)
- rel_hint_type        (short free-form hint; may be noisy)
- canonical_rel_name   (often "TBD" initially)
- canonical_rel_desc   (often empty initially)
- rel_cls              (often "TBD" initially)
- rel_cls_group        (often "TBD" initially)
- subject_entity_name, object_entity_name
- subject_class_label, subject_class_group
- object_class_label, object_class_group
- qualifiers (temporal, spatial, etc.)
- confidence, remarks, etc.

IMPORTANT CONTEXT ABOUT THE PIPELINE
------------------------------------
- ALL these fields (especially relation_name, rel_desc, and rel_hint_type) were
  generated by previous LLM stages. They are **approximate** and may be:
    - awkward in wording,
    - too specific,
    - too generic,
    - or slightly wrong.
- This step follows a "generate first, refine later" philosophy.
  Your job is to **refine, disambiguate, normalize, and improve human readability as a KG expert**, not to copy the wording blindly.
- Use upstream fields (especially relation_name, rel_desc, and rel_hint_type) as **semantic hints**, not as final label candidates AT ALL!

MULTI-RUN / REFINEMENT INSTRUCTIONS (READ ONLY WHEN THE FOLLOWING FIELDS ARE ALREADY FILLED: canonical_rel_name, canonical_rel_desc, rel_cls, rel_cls_group)
- Only read/apply the following guidance when at least one of the fields above is NOT "TBD" for relations in this chunk. It means we are in a refinement run.
- Do NOT be passive: if any pre-filled value is inconsistent, ambiguous, or improvable, you MUST propose a correction (use modify_rel_schema) with a concise justification.
- Only return [] if there is extremely strong evidence that no change is required (this is rare).
- This is an iterative process — act now with well-justified corrections using modify_rel_schema (include a short justification), rather than deferring small but meaningful fixes.
- This step will be repeated in later iterations; reasonable but imperfect changes can be corrected later. It is worse to miss a necessary change than to propose a well-justified change that might be slightly adjusted later.


ABOUT CLUSTERS (CRITICAL)
-------------------------
- The cluster you see is produced automatically from embeddings.
- The cluster is **only suggestive**, NOT a hard class:
    - It may contain multiple different canonical relations.
    - It may contain multiple different relation classes.
    - It may contain multiple different relation class groups.
- Your task is **NOT**:
    - "Find ONE canonical_rel_name that covers (almost) all relations in the cluster."
    - "Force all relations in the cluster into the same rel_cls or rel_cls_group."
- Your task **IS**:
    - For EACH relation instance, decide what canonical_rel_name, rel_cls,
      and rel_cls_group are appropriate (especially from the lens of a KG and Schema expert).
    - If some instances do NOT naturally share semantics, assign them different
      canonical_rel_name / rel_cls / rel_cls_group, even though they are
      in the same cluster.
    - If some other instances in the cluster naturally share exactly the same
      semantics, group them together in the same function call.

CRUCIAL DISTINCTION (SCOPE)
---------------------------
We use a 3-layer abstraction for relations:

1) canonical_rel_name
   - Fine-grained, predicate-level.
   - Groups relations that use essentially the SAME predicate meaning and direction.
   - This is the predicate that will be used as the edge label in the KG.
   - Examples: "occurs_in", "resists", "provides_resistance_to", "is_subtype_of",
     "has_metallurgical_structure", "grouped_with".

2) rel_cls
   - A broader relation CLASS that may cover multiple canonical_rel_name values.
   - Think of this as a family of similar predicates.
   - Examples (illustrative): "alloying_element_relation", "microstructure_relation",
     "hierarchy_relation", "corrosion_resistance_relation", "document_series_relation".
   - IMPORTANT: rel_cls should be more specific than broad groups, but more general
     than a single canonical_rel_name.

3) rel_cls_group
   - Very broad semantic DIMENSIONS:
       COMPOSITION, CAUSALITY, IDENTITY, TEMPORALITY, SPATIALITY, AGENCY,
       ASSOCIATION, MODIFICATION, USAGE, REQUIREMENT, etc.
   - This list is illustrative, NOT exhaustive.
   - Example:
       canonical_rel_name: "contains_alloying_element"
       rel_cls:            "alloying_element_relation"
       rel_cls_group:      "COMPOSITION"

RELATION-BY-RELATION THINKING (SUPER IMPORTANT)
-----------------------------------------------
For every relation instance in the cluster, conceptually ask:

1) What is the **best canonical predicate** (canonical_rel_name) for THIS instance,
   ignoring awkward wording in relation_name / rel_hint_type?
2) Which broader **relation class** (rel_cls) best describes this connection?
3) Which **rel_cls_group** (COMPOSITION, CAUSALITY, etc.) does it belong to?

Then:
- If you see other instances in the cluster with the **same semantics**, you may
  include them in the same function call (same canonical_rel_name / rel_cls / rel_cls_group).
- Do NOT try to find one label that covers ALL instances in the cluster.

NOISY HINTS AND HOW TO USE THEM
-------------------------------
- relation_name, rel_desc, rel_hint_type are hints, not perfect labels.
- Examples of bad patterns that you should NOT copy directly:
    - rel_hint_type = "co-classification" → this is awkward wording; interpret it
      as "these things are grouped together as co-equal categories" and choose
      a better canonical name / class (e.g., "grouped_with" with rel_cls
      "coequal_category_relation", rel_cls_group "ASSOCIATION" or "IDENTITY").
    - rel_hint_type = "causal" → this suggests rel_cls_group "CAUSALITY",
      but is NOT a good canonical_rel_name or rel_cls by itself.
- Also avoid redundant patterns like:
    - rel_cls = "composition_relation" when rel_cls_group = "COMPOSITION".
      In that case, choose a more specific rel_cls label, e.g.,
      "alloying_element_relation" or "microstructure_relation".

DEDUPLICATION & NORMALIZATION
-----------------------------
- Within a cluster, if you see multiple predicate variants that are semantically
  the same (e.g., "has_subtype", "is_subtype_of"), you MUST normalize them
  to **one** canonical_rel_name and apply it consistently:
    - For hierarchical relations, prefer a single consistent style, e.g., "is_subtype_of".
- Avoid creating trivial variants that only differ in small wording:
    - Do NOT keep both "provides_resistance_to" and "improves_resistance_to"
      if they are used identically for the same semantic link; pick one.
- Avoid rel_cls that simply repeats rel_cls_group with "_relation" added
  (e.g., "composition_relation" when rel_cls_group is "COMPOSITION").

WHAT YOU NEVER CHANGE
----------------------
- SUBJECT and OBJECT entities are fixed; you MUST NOT change them.
- You NEVER delete relation instances.
- You NEVER move qualifiers from relations onto nodes; qualifiers stay on the
  relation instance.

YOUR FUNCTION VOCABULARY
------------------------
You must return an ordered JSON ARRAY of function calls using ONLY:

1) set_canonical_rel
2) set_rel_cls
3) set_rel_cls_group
4) modify_rel_schema
5) add_rel_remark

Think RELATION-BY-RELATION first, and only group multiple relation_ids into the
same function call when you are genuinely sure they share the same semantics.

--------------------------------
FUNCTION DEFINITIONS
--------------------------------

1) set_canonical_rel
   Use this when you want to SET or ALIGN canonical_rel_name / canonical_rel_desc
   for one or more relation instances (especially when values are "TBD").

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "canonical_rel_name": <string>,           # REQUIRED, normalized predicate for KG edge
     "canonical_rel_desc": <string or null>,   # OPTIONAL, reusable description of this predicate
     "justification": <string>,                # REQUIRED: why these instances share this canonical predicate
     "remark": <string or null>,               # optional human-facing notes
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - canonical_rel_name should be a short predicate-style phrase, e.g. "occurs_in",
     "resists", "provides_resistance_to", "is_subtype_of", "has_metallurgical_structure".
   - Do NOT include qualifiers (e.g., "at high temperature") here.
   - Use this on relatively TIGHT groups of semantically equivalent predicates.
   - It is perfectly fine to call set_canonical_rel with a **single** relation_id
     when others in the cluster do not share the semantics.


2) set_rel_cls
   Use this when you want to SET or ALIGN rel_cls for one or more instances,
   grouping them into a broader relation class (family).

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "rel_cls": <string>,                      # REQUIRED: class name (e.g., "structure_relation")
     "justification": <string>,                # REQUIRED: why these instances belong to this class
     "remark": <string or null>,               # optional notes
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - A rel_cls usually covers MULTIPLE canonical_rel_name values, not just one.
   - Think of rel_cls as a conceptual family: e.g. "alloying_element_relation",
     "microstructure_relation", "document_series_relation".
   - Do NOT simply repeat rel_cls_group (e.g. avoid "composition_relation" when
     rel_cls_group is "COMPOSITION") unless there is truly no more specific
     and meaningful class you can provide.


3) set_rel_cls_group
   Use this when you want to SET or ALIGN rel_cls_group for one or more instances
   (or their classes), using a very broad semantic category.

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "rel_cls_group": <string>,                # REQUIRED: broad group (e.g., "COMPOSITION")
     "justification": <string>,                # REQUIRED: why this group fits
     "remark": <string or null>,               # optional notes
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - rel_cls_group is broad and somewhat orthogonal.
   - Typical groups: COMPOSITION, CAUSALITY, IDENTITY, TEMPORALITY, SPATIALITY,
     AGENCY, INTERACTION, ASSOCIATION, MODIFICATION, USAGE, REQUIREMENT, etc.
   - General hints like rel_hint_type="causal" are better mapped to rel_cls_group
     (CAUSALITY) than to canonical_rel_name.


4) modify_rel_schema
   Use this to REFINE or CORRECT existing schema fields for one or more relations
   (canonical_rel_name / canonical_rel_desc / rel_cls / rel_cls_group).

   args = {
     "relation_ids": [<relation_id>...],            # REQUIRED, at least 1
     "canonical_rel_name": <string or null>,        # OPTIONAL: new canonical name
     "canonical_rel_desc": <string or null>,        # OPTIONAL: new canonical description
     "rel_cls": <string or null>,                   # OPTIONAL: new relation class
     "rel_cls_group": <string or null>,             # OPTIONAL: new broad group
     "justification": <string>,                     # REQUIRED: why this modification is needed
     "remark": <string or null>,                    # optional notes / flags
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - Do NOT be passive: if any pre-filled value is inconsistent, ambiguous, or improvable, you MUST propose a correction using modify_rel_schema.
   - This is iterative: make well-justified corrections now (include a short justification); later runs may further refine them. 
   - It is worse to miss a necessary change than to propose a justified change that might be slightly adjusted later.
   - You MUST NOT try to change (poor) relation_names. As long as the canonical_rel_name, rel_cls, and rel_cls_group are fine, we are good. 
     But if they need correction, YOU MUST use modify_rel_schema to correct them. We will not use raw relation name in the KG. 
   - You MAY use this to normalize even minor variants (e.g., consolidate "has_subtype"
   and "is_subtype_of" to "is_subtype_of") when needed. We want consistent schema.
   


5) add_rel_remark
   Use this when you ONLY want to attach a human-facing remark / caveat / TODO
   without changing any schema fields.

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "remark": <string>,                        # REQUIRED: the remark text
     "justification": <string>,                # REQUIRED: why this remark is useful
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - Use this for issues outside scope (e.g., upstream entity resolution suspicion), or
     to flag ambiguous or borderline cases for later human review.

--------------------------------
INPUT RELATIONS (THIS CHUNK)
--------------------------------

Below is the JSON array of relation instances in THIS PART of a cluster
(we split very large clusters into smaller chunks just to keep the prompt size manageable):

[
  {
    "relation_id": "RelR_b6b32e66a3d7",
    "relation_name": "produces",
    "rel_desc": "The supernova explosion leaves behind a stellar remnant.",
    "rel_hint_type": "causal",
    "canonical_rel_name": "TBD",
    "canonical_rel_desc": "",
    "rel_cls": "TBD",
    "rel_cls_group": "TBD",
    "subject_entity_name": "supernova explosion",
    "object_entity_name": "stellar remnant",
    "subject_class_label": "Massive Star End-of-Life Components",
    "subject_class_group": "Stellar Evolution and End States",
    "object_class_label": "Massive Star End-of-Life Components",
    "object_class_group": "Stellar Evolution and End States",
    "qualifiers": {
      "TemporalQualifier": "after the explosion",
      "SpatialQualifier": "at the site of the exploded star (implied)",
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": "implied, not explicitly causal-worded",
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": null
    },
    "confidence": 0.78,
    "remarks": [
      "Outcome is somewhat implicit but standard in stellar evolution."
    ]
  },
  {
    "relation_id": "RelR_410072abaead",
    "relation_name": "leaves_remnant",
    "rel_desc": "The massive star leaves behind a stellar remnant after its death.",
    "rel_hint_type": "result",
    "canonical_rel_name": "TBD",
    "canonical_rel_desc": "",
    "rel_cls": "TBD",
    "rel_cls_group": "TBD",
    "subject_entity_name": "massive star",
    "object_entity_name": "stellar remnant",
    "subject_class_label": "Massive Star End-of-Life Components",
    "subject_class_group": "Stellar Evolution and End States",
    "object_class_label": "Massive Star End-of-Life Components",
    "object_class_group": "Stellar Evolution and End States",
    "qualifiers": {
      "TemporalQualifier": "after star's death",
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": "after exhausting fuel and supernova explosion",
      "UncertaintyQualifier": null,
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": null
    },
    "confidence": 0.86,
    "remarks": []
  },
  {
    "relation_id": "RelR_8331c8d145cd",
    "relation_name": "forms",
    "rel_desc": "A stellar remnant collapses further to form a black hole.",
    "rel_hint_type": "causal",
    "canonical_rel_name": "TBD",
    "canonical_rel_desc": "",
    "rel_cls": "TBD",
    "rel_cls_group": "TBD",
    "subject_entity_name": "stellar remnant",
    "object_entity_name": "black hole",
    "subject_class_label": "Massive Star End-of-Life Components",
    "subject_class_group": "Stellar Evolution and End States",
    "object_class_label": "Black Holes (Astrophysical Objects)",
    "object_class_group": "Black Holes",
    "qualifiers": {
      "TemporalQualifier": "after the supernova event",
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": "for sufficiently massive remnants (implied)",
      "UncertaintyQualifier": "condition on mass is implied but not stated",
      "CausalHint": "are born from",
      "LogicalMarker": null,
      "OtherQualifier": null
    },
    "confidence": 0.94,
    "remarks": []
  }
]

--------------------------------
OUTPUT
--------------------------------

Return ONLY the JSON ARRAY of function calls, e.g.:

[
  {
    "function": "set_canonical_rel",
    "args": { ... }
  },
  {
    "function": "set_rel_cls",
    "args": { ... }
  },
  ...
]

- If this chunk is already perfect (rare), you MAY return [].
- Every call MUST include a "justification".
- Use "remark" (or add_rel_remark) to flag issues or uncertainties that are outside
  the scope of these functions.
