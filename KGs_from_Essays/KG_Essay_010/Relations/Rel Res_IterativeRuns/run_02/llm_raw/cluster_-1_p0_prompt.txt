
You are a very proactive RELATION-RESOLUTION assistant, and an expert in knowledge graphs (KGs) and schema (ontology) design.

You are given a CLUSTER of relation INSTANCES from a context-enriched technical KG.
Each relation instance already connects specific subject and object entities, and has:

- relation_id
- relation_name        (raw, from Relation Recognition; may be noisy)
- rel_desc             (instance-level description; may be verbose)
- rel_hint_type        (short free-form hint; may be noisy)
- canonical_rel_name   (often "TBD" initially)
- canonical_rel_desc   (often empty initially)
- rel_cls              (often "TBD" initially)
- rel_cls_group        (often "TBD" initially)
- subject_entity_name, object_entity_name
- subject_class_label, subject_class_group
- object_class_label, object_class_group
- qualifiers (temporal, spatial, etc.)
- confidence, remarks, etc.

IMPORTANT CONTEXT ABOUT THE PIPELINE
------------------------------------
- ALL these fields (especially relation_name, rel_desc, and rel_hint_type) were
  generated by previous LLM stages. They are **approximate** and may be:
    - awkward in wording,
    - too specific,
    - too generic,
    - or slightly wrong.
- This step follows a "generate first, refine later" philosophy.
  Your job is to **refine, disambiguate, normalize, and improve human readability as a KG expert**, not to copy the wording blindly.
- Use upstream fields (especially relation_name, rel_desc, and rel_hint_type) as **semantic hints**, not as final label candidates AT ALL!

MULTI-RUN / REFINEMENT INSTRUCTIONS (READ ONLY WHEN THE FOLLOWING FIELDS ARE ALREADY FILLED: canonical_rel_name, canonical_rel_desc, rel_cls, rel_cls_group)
- Only read/apply the following guidance when at least one of the fields above is NOT "TBD" for relations in this chunk. It means we are in a refinement run.
- Do NOT be passive: if any pre-filled value is inconsistent, ambiguous, or improvable, you MUST propose a correction (use modify_rel_schema) with a concise justification.
- Only return [] if there is extremely strong evidence that no change is required (this is rare).
- This is an iterative process — act now with well-justified corrections using modify_rel_schema (include a short justification), rather than deferring small but meaningful fixes.
- This step will be repeated in later iterations; reasonable but imperfect changes can be corrected later. It is worse to miss a necessary change than to propose a well-justified change that might be slightly adjusted later.


ABOUT CLUSTERS (CRITICAL)
-------------------------
- The cluster you see is produced automatically from embeddings.
- The cluster is **only suggestive**, NOT a hard class:
    - It may contain multiple different canonical relations.
    - It may contain multiple different relation classes.
    - It may contain multiple different relation class groups.
- Your task is **NOT**:
    - "Find ONE canonical_rel_name that covers (almost) all relations in the cluster."
    - "Force all relations in the cluster into the same rel_cls or rel_cls_group."
- Your task **IS**:
    - For EACH relation instance, decide what canonical_rel_name, rel_cls,
      and rel_cls_group are appropriate (especially from the lens of a KG and Schema expert).
    - If some instances do NOT naturally share semantics, assign them different
      canonical_rel_name / rel_cls / rel_cls_group, even though they are
      in the same cluster.
    - If some other instances in the cluster naturally share exactly the same
      semantics, group them together in the same function call.

CRUCIAL DISTINCTION (SCOPE)
---------------------------
We use a 3-layer abstraction for relations:

1) canonical_rel_name
   - Fine-grained, predicate-level.
   - Groups relations that use essentially the SAME predicate meaning and direction.
   - This is the predicate that will be used as the edge label in the KG.
   - Examples: "occurs_in", "resists", "provides_resistance_to", "is_subtype_of",
     "has_metallurgical_structure", "grouped_with".

2) rel_cls
   - A broader relation CLASS that may cover multiple canonical_rel_name values.
   - Think of this as a family of similar predicates.
   - Examples (illustrative): "alloying_element_relation", "microstructure_relation",
     "hierarchy_relation", "corrosion_resistance_relation", "document_series_relation".
   - IMPORTANT: rel_cls should be more specific than broad groups, but more general
     than a single canonical_rel_name.

3) rel_cls_group
   - Very broad semantic DIMENSIONS:
       COMPOSITION, CAUSALITY, IDENTITY, TEMPORALITY, SPATIALITY, AGENCY,
       ASSOCIATION, MODIFICATION, USAGE, REQUIREMENT, etc.
   - This list is illustrative, NOT exhaustive.
   - Example:
       canonical_rel_name: "contains_alloying_element"
       rel_cls:            "alloying_element_relation"
       rel_cls_group:      "COMPOSITION"

RELATION-BY-RELATION THINKING (SUPER IMPORTANT)
-----------------------------------------------
For every relation instance in the cluster, conceptually ask:

1) What is the **best canonical predicate** (canonical_rel_name) for THIS instance,
   ignoring awkward wording in relation_name / rel_hint_type?
2) Which broader **relation class** (rel_cls) best describes this connection?
3) Which **rel_cls_group** (COMPOSITION, CAUSALITY, etc.) does it belong to?

Then:
- If you see other instances in the cluster with the **same semantics**, you may
  include them in the same function call (same canonical_rel_name / rel_cls / rel_cls_group).
- Do NOT try to find one label that covers ALL instances in the cluster.

NOISY HINTS AND HOW TO USE THEM
-------------------------------
- relation_name, rel_desc, rel_hint_type are hints, not perfect labels.
- Examples of bad patterns that you should NOT copy directly:
    - rel_hint_type = "co-classification" → this is awkward wording; interpret it
      as "these things are grouped together as co-equal categories" and choose
      a better canonical name / class (e.g., "grouped_with" with rel_cls
      "coequal_category_relation", rel_cls_group "ASSOCIATION" or "IDENTITY").
    - rel_hint_type = "causal" → this suggests rel_cls_group "CAUSALITY",
      but is NOT a good canonical_rel_name or rel_cls by itself.
- Also avoid redundant patterns like:
    - rel_cls = "composition_relation" when rel_cls_group = "COMPOSITION".
      In that case, choose a more specific rel_cls label, e.g.,
      "alloying_element_relation" or "microstructure_relation".

DEDUPLICATION & NORMALIZATION
-----------------------------
- Within a cluster, if you see multiple predicate variants that are semantically
  the same (e.g., "has_subtype", "is_subtype_of"), you MUST normalize them
  to **one** canonical_rel_name and apply it consistently:
    - For hierarchical relations, prefer a single consistent style, e.g., "is_subtype_of".
- Avoid creating trivial variants that only differ in small wording:
    - Do NOT keep both "provides_resistance_to" and "improves_resistance_to"
      if they are used identically for the same semantic link; pick one.
- Avoid rel_cls that simply repeats rel_cls_group with "_relation" added
  (e.g., "composition_relation" when rel_cls_group is "COMPOSITION").

WHAT YOU NEVER CHANGE
----------------------
- SUBJECT and OBJECT entities are fixed; you MUST NOT change them.
- You NEVER delete relation instances.
- You NEVER move qualifiers from relations onto nodes; qualifiers stay on the
  relation instance.

YOUR FUNCTION VOCABULARY
------------------------
You must return an ordered JSON ARRAY of function calls using ONLY:

1) set_canonical_rel
2) set_rel_cls
3) set_rel_cls_group
4) modify_rel_schema
5) add_rel_remark

Think RELATION-BY-RELATION first, and only group multiple relation_ids into the
same function call when you are genuinely sure they share the same semantics.

--------------------------------
FUNCTION DEFINITIONS
--------------------------------

1) set_canonical_rel
   Use this when you want to SET or ALIGN canonical_rel_name / canonical_rel_desc
   for one or more relation instances (especially when values are "TBD").

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "canonical_rel_name": <string>,           # REQUIRED, normalized predicate for KG edge
     "canonical_rel_desc": <string or null>,   # OPTIONAL, reusable description of this predicate
     "justification": <string>,                # REQUIRED: why these instances share this canonical predicate
     "remark": <string or null>,               # optional human-facing notes
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - canonical_rel_name should be a short predicate-style phrase, e.g. "occurs_in",
     "resists", "provides_resistance_to", "is_subtype_of", "has_metallurgical_structure".
   - Do NOT include qualifiers (e.g., "at high temperature") here.
   - Use this on relatively TIGHT groups of semantically equivalent predicates.
   - It is perfectly fine to call set_canonical_rel with a **single** relation_id
     when others in the cluster do not share the semantics.


2) set_rel_cls
   Use this when you want to SET or ALIGN rel_cls for one or more instances,
   grouping them into a broader relation class (family).

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "rel_cls": <string>,                      # REQUIRED: class name (e.g., "structure_relation")
     "justification": <string>,                # REQUIRED: why these instances belong to this class
     "remark": <string or null>,               # optional notes
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - A rel_cls usually covers MULTIPLE canonical_rel_name values, not just one.
   - Think of rel_cls as a conceptual family: e.g. "alloying_element_relation",
     "microstructure_relation", "document_series_relation".
   - Do NOT simply repeat rel_cls_group (e.g. avoid "composition_relation" when
     rel_cls_group is "COMPOSITION") unless there is truly no more specific
     and meaningful class you can provide.


3) set_rel_cls_group
   Use this when you want to SET or ALIGN rel_cls_group for one or more instances
   (or their classes), using a very broad semantic category.

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "rel_cls_group": <string>,                # REQUIRED: broad group (e.g., "COMPOSITION")
     "justification": <string>,                # REQUIRED: why this group fits
     "remark": <string or null>,               # optional notes
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - rel_cls_group is broad and somewhat orthogonal.
   - Typical groups: COMPOSITION, CAUSALITY, IDENTITY, TEMPORALITY, SPATIALITY,
     AGENCY, INTERACTION, ASSOCIATION, MODIFICATION, USAGE, REQUIREMENT, etc.
   - General hints like rel_hint_type="causal" are better mapped to rel_cls_group
     (CAUSALITY) than to canonical_rel_name.


4) modify_rel_schema
   Use this to REFINE or CORRECT existing schema fields for one or more relations
   (canonical_rel_name / canonical_rel_desc / rel_cls / rel_cls_group).

   args = {
     "relation_ids": [<relation_id>...],            # REQUIRED, at least 1
     "canonical_rel_name": <string or null>,        # OPTIONAL: new canonical name
     "canonical_rel_desc": <string or null>,        # OPTIONAL: new canonical description
     "rel_cls": <string or null>,                   # OPTIONAL: new relation class
     "rel_cls_group": <string or null>,             # OPTIONAL: new broad group
     "justification": <string>,                     # REQUIRED: why this modification is needed
     "remark": <string or null>,                    # optional notes / flags
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - Do NOT be passive: if any pre-filled value is inconsistent, ambiguous, or improvable, you MUST propose a correction using modify_rel_schema.
   - This is iterative: make well-justified corrections now (include a short justification); later runs may further refine them. 
   - It is worse to miss a necessary change than to propose a justified change that might be slightly adjusted later.
   - You MUST NOT try to change (poor) relation_names. As long as the canonical_rel_name, rel_cls, and rel_cls_group are fine, we are good. 
     But if they need correction, YOU MUST use modify_rel_schema to correct them. We will not use raw relation name in the KG. 
   - You MAY use this to normalize even minor variants (e.g., consolidate "has_subtype"
   and "is_subtype_of" to "is_subtype_of") when needed. We want consistent schema.
   


5) add_rel_remark
   Use this when you ONLY want to attach a human-facing remark / caveat / TODO
   without changing any schema fields.

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "remark": <string>,                        # REQUIRED: the remark text
     "justification": <string>,                # REQUIRED: why this remark is useful
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - Use this for issues outside scope (e.g., upstream entity resolution suspicion), or
     to flag ambiguous or borderline cases for later human review.

--------------------------------
INPUT RELATIONS (THIS CHUNK)
--------------------------------

Below is the JSON array of relation instances in THIS PART of a cluster
(we split very large clusters into smaller chunks just to keep the prompt size manageable):

[
  {
    "relation_id": "RelR_f3a21a2463ab",
    "relation_name": "has_property_set",
    "rel_desc": "Black holes have a set of characteristic physical properties that are being discussed.",
    "rel_hint_type": "property",
    "canonical_rel_name": "has_physical_property",
    "canonical_rel_desc": "Links a physical object or phenomenon to one of its physical properties or a set of such properties.",
    "rel_cls": "physical_property_relation",
    "rel_cls_group": "ATTRIBUTE",
    "subject_entity_name": "black holes",
    "object_entity_name": "properties of black holes",
    "subject_class_label": "Black Hole Phenomena",
    "subject_class_group": "Astrophysics",
    "object_class_label": "Black Holes and Physical Properties",
    "object_class_group": "Black Holes and Their Properties",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "DescriptiveScope: part of the topics to be explored"
    },
    "confidence": 0.9,
    "remarks": []
  },
  {
    "relation_id": "RelR_015337c55f4e",
    "relation_name": "describes_evolution_of",
    "rel_desc": "The star life cycle refers to the evolutionary progression of a massive star.",
    "rel_hint_type": "descriptive",
    "canonical_rel_name": "describes_evolution_of",
    "canonical_rel_desc": "Subject describes or represents the temporal evolution or life cycle of the object.",
    "rel_cls": "representation_relation",
    "rel_cls_group": "REPRESENTATION",
    "subject_entity_name": "star life cycle",
    "object_entity_name": "massive star",
    "subject_class_label": "Stellar End-of-Life Processes",
    "subject_class_group": "Stellar Evolution and End States",
    "object_class_label": "Massive Star End-of-Life Components",
    "object_class_group": "Stellar Evolution and End States",
    "qualifiers": {
      "TemporalQualifier": "from formation to end of life",
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": "star type (massive) is implicit",
      "CausalHint": null,
      "LogicalMarker": "When",
      "OtherQualifier": null
    },
    "confidence": 0.7,
    "remarks": [
      "Star type is not explicitly restated; mapping to massive star is inferred.",
      "Star type is not explicitly restated; mapping to massive star is inferred.",
      "Star type is not explicitly restated; mapping to massive star is inferred."
    ]
  },
  {
    "relation_id": "RelR_ab875fd04a69",
    "relation_name": "creates",
    "rel_desc": "The stellar collapse creates the black hole singularity.",
    "rel_hint_type": "causal",
    "canonical_rel_name": "creates",
    "canonical_rel_desc": "Indicates that the subject process brings the object entity into existence or produces it.",
    "rel_cls": "process_output_relation",
    "rel_cls_group": "CAUSALITY",
    "subject_entity_name": "stellar collapse",
    "object_entity_name": "black hole singularity",
    "subject_class_label": "Stellar End-of-Life Processes",
    "subject_class_group": "Stellar Evolution and End States",
    "object_class_label": "Black Hole Structural Components",
    "object_class_group": "Black Holes",
    "qualifiers": {
      "TemporalQualifier": "during the collapse event",
      "SpatialQualifier": "at the center of the forming black hole",
      "OperationalConstraint": null,
      "ConditionExpression": "after end of life and collapse onset",
      "UncertaintyQualifier": null,
      "CausalHint": "creating",
      "LogicalMarker": null,
      "OtherQualifier": null
    },
    "confidence": 0.94,
    "remarks": []
  },
  {
    "relation_id": "RelR_713a0ea35135",
    "relation_name": "is_property_of",
    "rel_desc": "The size of black holes is a property characterizing black holes.",
    "rel_hint_type": "attribute",
    "canonical_rel_name": "is_property_of",
    "canonical_rel_desc": "Links a property, attribute, or quality node to the entity that bears this property.",
    "rel_cls": "entity_property_relation",
    "rel_cls_group": "ATTRIBUTE",
    "subject_entity_name": "size of black holes",
    "object_entity_name": "black holes",
    "subject_class_label": "Black Hole Size Measures",
    "subject_class_group": "Black Hole Schwarzschild Radius Concepts",
    "object_class_label": "Black Hole Phenomena",
    "object_class_group": "Astrophysics",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": null,
      "LogicalMarker": "of",
      "OtherQualifier": null
    },
    "confidence": 0.9,
    "remarks": [
      "This is somewhat intrinsic but represented as a relation for context.",
      "This is somewhat intrinsic but represented as a relation for context.",
      "This is somewhat intrinsic but represented as a relation for context."
    ]
  },
  {
    "relation_id": "RelR_bf07c71f41d6",
    "relation_name": "interacts_with",
    "rel_desc": "Information is described as falling into a black hole, linking the concept of information with the black hole system.",
    "rel_hint_type": "physical_interaction",
    "canonical_rel_name": "enters_into",
    "canonical_rel_desc": "Indicates that an entity (e.g., information, matter, or radiation) transitions into and becomes contained within a black hole or similar system.",
    "rel_cls": "ingress_interaction_relation",
    "rel_cls_group": "INTERACTION",
    "subject_entity_name": "information",
    "object_entity_name": "black hole",
    "subject_class_label": "Black Hole Information & Paradox Concepts",
    "subject_class_group": "Black Hole Information & Holography",
    "object_class_label": "Black Holes (Astrophysical Objects)",
    "object_class_group": "Black Holes",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": "into a black hole",
      "OperationalConstraint": "during infall into the black hole",
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "Process: infall of information into black hole"
    },
    "confidence": 0.78,
    "remarks": [
      "Relation semantics approximate; main goal is to encode that the fate of information is tied to it entering a black hole.",
      "Relation semantics approximate; main goal is to encode that the fate of information is tied to it entering a black hole.",
      "Relation semantics approximate; main goal is to encode that the fate of information is tied to it entering a black hole."
    ]
  },
  {
    "relation_id": "RelR_3b3cfd2cd518",
    "relation_name": "caused_by",
    "rel_desc": "The 2015 gravitational-wave discovery arose from the merger of two black holes.",
    "rel_hint_type": "causal",
    "canonical_rel_name": "is_caused_by",
    "canonical_rel_desc": "Indicates that the subject event, phenomenon, or state occurs as a result of the object cause or driving factor.",
    "rel_cls": "physical_causation_relation",
    "rel_cls_group": "CAUSALITY",
    "subject_entity_name": "discovery of gravitational waves in 2015",
    "object_entity_name": "merger of two black holes",
    "subject_class_label": "Gravitational-Wave Observation Context",
    "subject_class_group": "Gravitation and General Relativity",
    "object_class_label": "Compact-Object Mergers Emitting Gravitational Waves",
    "object_class_group": "Gravitation and General Relativity",
    "qualifiers": {
      "TemporalQualifier": "during the black hole merger event observed",
      "SpatialQualifier": null,
      "OperationalConstraint": "binary black hole coalescence",
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": "resulting from",
      "LogicalMarker": null,
      "OtherQualifier": "SourceEvent: merger of two black holes that produced the signal"
    },
    "confidence": 0.96,
    "remarks": []
  },
  {
    "relation_id": "RelR_d8824d8021b0",
    "relation_name": "has_open_question_on",
    "rel_desc": "One of the biggest unresolved puzzles about black holes concerns the nature of their central singularity.",
    "rel_hint_type": "knowledge_gap",
    "canonical_rel_name": "has_open_question_about",
    "canonical_rel_desc": "Indicates that the subject is associated with an unresolved scientific or conceptual question concerning the object.",
    "rel_cls": "knowledge_gap_relation",
    "rel_cls_group": "EPISTEMIC",
    "subject_entity_name": "black holes",
    "object_entity_name": "black hole singularity",
    "subject_class_label": "Black Hole Phenomena",
    "subject_class_group": "Astrophysics",
    "object_class_label": "Black Hole Structural Components",
    "object_class_group": "Black Holes",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": "regarding black holes",
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": "unresolved",
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "PuzzleAspect: nature of the singularity"
    },
    "confidence": 0.9,
    "remarks": []
  },
  {
    "relation_id": "RelR_2c40eb31fe0c",
    "relation_name": "exists_in",
    "rel_desc": "Black holes are phenomena that exist within the universe.",
    "rel_hint_type": "containment",
    "canonical_rel_name": "exists_in",
    "canonical_rel_desc": "Indicates that the subject phenomenon or entity exists or occurs within the spatial or cosmological domain denoted by the object.",
    "rel_cls": "existence_location_relation",
    "rel_cls_group": "SPATIALITY",
    "subject_entity_name": "black holes",
    "object_entity_name": "universe",
    "subject_class_label": "Black Holes and Physical Properties",
    "subject_class_group": "Black Holes and Their Properties",
    "object_class_label": "Universe (Cosmological Whole)",
    "object_class_group": "Cosmology and Fundamental Physics",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": "in the universe",
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "Characterization: fascinating and enigmatic"
    },
    "confidence": 0.9,
    "remarks": []
  },
  {
    "relation_id": "RelR_28f185d047eb",
    "relation_name": "aspect_of",
    "rel_desc": "The mysteries are unresolved aspects associated with black holes.",
    "rel_hint_type": "association",
    "canonical_rel_name": "is_about",
    "canonical_rel_desc": "Indicates that the subject concept, topic, or question concerns or is about the object.",
    "rel_cls": "conceptual_association_relation",
    "rel_cls_group": "ASSOCIATION",
    "subject_entity_name": "mysteries of black holes",
    "object_entity_name": "black holes",
    "subject_class_label": "Black Hole Concepts & Open Questions",
    "subject_class_group": "Astrophysics – Black Holes",
    "object_class_label": "Black Hole Phenomena",
    "object_class_group": "Astrophysics",
    "qualifiers": {
      "TemporalQualifier": "ongoing quest",
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "Status: open scientific questions about black holes"
    },
    "confidence": 0.9,
    "remarks": []
  }
]

--------------------------------
OUTPUT
--------------------------------

Return ONLY the JSON ARRAY of function calls, e.g.:

[
  {
    "function": "set_canonical_rel",
    "args": { ... }
  },
  {
    "function": "set_rel_cls",
    "args": { ... }
  },
  ...
]

- If this chunk is already perfect (rare), you MAY return [].
- Every call MUST include a "justification".
- Use "remark" (or add_rel_remark) to flag issues or uncertainties that are outside
  the scope of these functions.
