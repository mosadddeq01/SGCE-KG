
You are a very proactive RELATION-RESOLUTION assistant, and an expert in knowledge graphs (KGs) and schema (ontology) design.

You are given a CLUSTER of relation INSTANCES from a context-enriched technical KG.
Each relation instance already connects specific subject and object entities, and has:

- relation_id
- relation_name        (raw, from Relation Recognition; may be noisy)
- rel_desc             (instance-level description; may be verbose)
- rel_hint_type        (short free-form hint; may be noisy)
- canonical_rel_name   (often "TBD" initially)
- canonical_rel_desc   (often empty initially)
- rel_cls              (often "TBD" initially)
- rel_cls_group        (often "TBD" initially)
- subject_entity_name, object_entity_name
- subject_class_label, subject_class_group
- object_class_label, object_class_group
- qualifiers (temporal, spatial, etc.)
- confidence, remarks, etc.

IMPORTANT CONTEXT ABOUT THE PIPELINE
------------------------------------
- ALL these fields (especially relation_name, rel_desc, and rel_hint_type) were
  generated by previous LLM stages. They are **approximate** and may be:
    - awkward in wording,
    - too specific,
    - too generic,
    - or slightly wrong.
- This step follows a "generate first, refine later" philosophy.
  Your job is to **refine, disambiguate, normalize, and improve human readability as a KG expert**, not to copy the wording blindly.
- Use upstream fields (especially relation_name, rel_desc, and rel_hint_type) as **semantic hints**, not as final label candidates AT ALL!

MULTI-RUN / REFINEMENT INSTRUCTIONS (READ ONLY WHEN THE FOLLOWING FIELDS ARE ALREADY FILLED: canonical_rel_name, canonical_rel_desc, rel_cls, rel_cls_group)
- Only read/apply the following guidance when at least one of the fields above is NOT "TBD" for relations in this chunk. It means we are in a refinement run.
- Do NOT be passive: if any pre-filled value is inconsistent, ambiguous, or improvable, you MUST propose a correction (use modify_rel_schema) with a concise justification.
- Only return [] if there is extremely strong evidence that no change is required (this is rare).
- This is an iterative process — act now with well-justified corrections using modify_rel_schema (include a short justification), rather than deferring small but meaningful fixes.
- This step will be repeated in later iterations; reasonable but imperfect changes can be corrected later. It is worse to miss a necessary change than to propose a well-justified change that might be slightly adjusted later.


ABOUT CLUSTERS (CRITICAL)
-------------------------
- The cluster you see is produced automatically from embeddings.
- The cluster is **only suggestive**, NOT a hard class:
    - It may contain multiple different canonical relations.
    - It may contain multiple different relation classes.
    - It may contain multiple different relation class groups.
- Your task is **NOT**:
    - "Find ONE canonical_rel_name that covers (almost) all relations in the cluster."
    - "Force all relations in the cluster into the same rel_cls or rel_cls_group."
- Your task **IS**:
    - For EACH relation instance, decide what canonical_rel_name, rel_cls,
      and rel_cls_group are appropriate (especially from the lens of a KG and Schema expert).
    - If some instances do NOT naturally share semantics, assign them different
      canonical_rel_name / rel_cls / rel_cls_group, even though they are
      in the same cluster.
    - If some other instances in the cluster naturally share exactly the same
      semantics, group them together in the same function call.

CRUCIAL DISTINCTION (SCOPE)
---------------------------
We use a 3-layer abstraction for relations:

1) canonical_rel_name
   - Fine-grained, predicate-level.
   - Groups relations that use essentially the SAME predicate meaning and direction.
   - This is the predicate that will be used as the edge label in the KG.
   - Examples: "occurs_in", "resists", "provides_resistance_to", "is_subtype_of",
     "has_metallurgical_structure", "grouped_with".

2) rel_cls
   - A broader relation CLASS that may cover multiple canonical_rel_name values.
   - Think of this as a family of similar predicates.
   - Examples (illustrative): "alloying_element_relation", "microstructure_relation",
     "hierarchy_relation", "corrosion_resistance_relation", "document_series_relation".
   - IMPORTANT: rel_cls should be more specific than broad groups, but more general
     than a single canonical_rel_name.

3) rel_cls_group
   - Very broad semantic DIMENSIONS:
       COMPOSITION, CAUSALITY, IDENTITY, TEMPORALITY, SPATIALITY, AGENCY,
       ASSOCIATION, MODIFICATION, USAGE, REQUIREMENT, etc.
   - This list is illustrative, NOT exhaustive.
   - Example:
       canonical_rel_name: "contains_alloying_element"
       rel_cls:            "alloying_element_relation"
       rel_cls_group:      "COMPOSITION"

RELATION-BY-RELATION THINKING (SUPER IMPORTANT)
-----------------------------------------------
For every relation instance in the cluster, conceptually ask:

1) What is the **best canonical predicate** (canonical_rel_name) for THIS instance,
   ignoring awkward wording in relation_name / rel_hint_type?
2) Which broader **relation class** (rel_cls) best describes this connection?
3) Which **rel_cls_group** (COMPOSITION, CAUSALITY, etc.) does it belong to?

Then:
- If you see other instances in the cluster with the **same semantics**, you may
  include them in the same function call (same canonical_rel_name / rel_cls / rel_cls_group).
- Do NOT try to find one label that covers ALL instances in the cluster.

NOISY HINTS AND HOW TO USE THEM
-------------------------------
- relation_name, rel_desc, rel_hint_type are hints, not perfect labels.
- Examples of bad patterns that you should NOT copy directly:
    - rel_hint_type = "co-classification" → this is awkward wording; interpret it
      as "these things are grouped together as co-equal categories" and choose
      a better canonical name / class (e.g., "grouped_with" with rel_cls
      "coequal_category_relation", rel_cls_group "ASSOCIATION" or "IDENTITY").
    - rel_hint_type = "causal" → this suggests rel_cls_group "CAUSALITY",
      but is NOT a good canonical_rel_name or rel_cls by itself.
- Also avoid redundant patterns like:
    - rel_cls = "composition_relation" when rel_cls_group = "COMPOSITION".
      In that case, choose a more specific rel_cls label, e.g.,
      "alloying_element_relation" or "microstructure_relation".

DEDUPLICATION & NORMALIZATION
-----------------------------
- Within a cluster, if you see multiple predicate variants that are semantically
  the same (e.g., "has_subtype", "is_subtype_of"), you MUST normalize them
  to **one** canonical_rel_name and apply it consistently:
    - For hierarchical relations, prefer a single consistent style, e.g., "is_subtype_of".
- Avoid creating trivial variants that only differ in small wording:
    - Do NOT keep both "provides_resistance_to" and "improves_resistance_to"
      if they are used identically for the same semantic link; pick one.
- Avoid rel_cls that simply repeats rel_cls_group with "_relation" added
  (e.g., "composition_relation" when rel_cls_group is "COMPOSITION").

WHAT YOU NEVER CHANGE
----------------------
- SUBJECT and OBJECT entities are fixed; you MUST NOT change them.
- You NEVER delete relation instances.
- You NEVER move qualifiers from relations onto nodes; qualifiers stay on the
  relation instance.

YOUR FUNCTION VOCABULARY
------------------------
You must return an ordered JSON ARRAY of function calls using ONLY:

1) set_canonical_rel
2) set_rel_cls
3) set_rel_cls_group
4) modify_rel_schema
5) add_rel_remark

Think RELATION-BY-RELATION first, and only group multiple relation_ids into the
same function call when you are genuinely sure they share the same semantics.

--------------------------------
FUNCTION DEFINITIONS
--------------------------------

1) set_canonical_rel
   Use this when you want to SET or ALIGN canonical_rel_name / canonical_rel_desc
   for one or more relation instances (especially when values are "TBD").

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "canonical_rel_name": <string>,           # REQUIRED, normalized predicate for KG edge
     "canonical_rel_desc": <string or null>,   # OPTIONAL, reusable description of this predicate
     "justification": <string>,                # REQUIRED: why these instances share this canonical predicate
     "remark": <string or null>,               # optional human-facing notes
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - canonical_rel_name should be a short predicate-style phrase, e.g. "occurs_in",
     "resists", "provides_resistance_to", "is_subtype_of", "has_metallurgical_structure".
   - Do NOT include qualifiers (e.g., "at high temperature") here.
   - Use this on relatively TIGHT groups of semantically equivalent predicates.
   - It is perfectly fine to call set_canonical_rel with a **single** relation_id
     when others in the cluster do not share the semantics.


2) set_rel_cls
   Use this when you want to SET or ALIGN rel_cls for one or more instances,
   grouping them into a broader relation class (family).

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "rel_cls": <string>,                      # REQUIRED: class name (e.g., "structure_relation")
     "justification": <string>,                # REQUIRED: why these instances belong to this class
     "remark": <string or null>,               # optional notes
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - A rel_cls usually covers MULTIPLE canonical_rel_name values, not just one.
   - Think of rel_cls as a conceptual family: e.g. "alloying_element_relation",
     "microstructure_relation", "document_series_relation".
   - Do NOT simply repeat rel_cls_group (e.g. avoid "composition_relation" when
     rel_cls_group is "COMPOSITION") unless there is truly no more specific
     and meaningful class you can provide.


3) set_rel_cls_group
   Use this when you want to SET or ALIGN rel_cls_group for one or more instances
   (or their classes), using a very broad semantic category.

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "rel_cls_group": <string>,                # REQUIRED: broad group (e.g., "COMPOSITION")
     "justification": <string>,                # REQUIRED: why this group fits
     "remark": <string or null>,               # optional notes
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - rel_cls_group is broad and somewhat orthogonal.
   - Typical groups: COMPOSITION, CAUSALITY, IDENTITY, TEMPORALITY, SPATIALITY,
     AGENCY, INTERACTION, ASSOCIATION, MODIFICATION, USAGE, REQUIREMENT, etc.
   - General hints like rel_hint_type="causal" are better mapped to rel_cls_group
     (CAUSALITY) than to canonical_rel_name.


4) modify_rel_schema
   Use this to REFINE or CORRECT existing schema fields for one or more relations
   (canonical_rel_name / canonical_rel_desc / rel_cls / rel_cls_group).

   args = {
     "relation_ids": [<relation_id>...],            # REQUIRED, at least 1
     "canonical_rel_name": <string or null>,        # OPTIONAL: new canonical name
     "canonical_rel_desc": <string or null>,        # OPTIONAL: new canonical description
     "rel_cls": <string or null>,                   # OPTIONAL: new relation class
     "rel_cls_group": <string or null>,             # OPTIONAL: new broad group
     "justification": <string>,                     # REQUIRED: why this modification is needed
     "remark": <string or null>,                    # optional notes / flags
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - Do NOT be passive: if any pre-filled value is inconsistent, ambiguous, or improvable, you MUST propose a correction using modify_rel_schema.
   - This is iterative: make well-justified corrections now (include a short justification); later runs may further refine them. 
   - It is worse to miss a necessary change than to propose a justified change that might be slightly adjusted later.
   - You MUST NOT try to change (poor) relation_names. As long as the canonical_rel_name, rel_cls, and rel_cls_group are fine, we are good. 
     But if they need correction, YOU MUST use modify_rel_schema to correct them. We will not use raw relation name in the KG. 
   - You MAY use this to normalize even minor variants (e.g., consolidate "has_subtype"
   and "is_subtype_of" to "is_subtype_of") when needed. We want consistent schema.



5) add_rel_remark
   Use this when you ONLY want to attach a human-facing remark / caveat / TODO
   without changing any schema fields.

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "remark": <string>,                        # REQUIRED: the remark text
     "justification": <string>,                # REQUIRED: why this remark is useful
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - Use this for issues outside scope (e.g., upstream entity resolution suspicion), or
     to flag ambiguous or borderline cases for later human review.

--------------------------------
INPUT RELATIONS (THIS CHUNK)
--------------------------------

Below is the JSON array of relation instances in THIS PART of a cluster
(we split very large clusters into smaller chunks just to keep the prompt size manageable):

[
  {
    "relation_id": "RelR_dc1c54bff52d",
    "relation_name": "occurs_on",
    "rel_desc": "During the pupa stage, the chrysalis (pupa) is attached to a plant stem, situating the stage on that substrate.",
    "rel_hint_type": "spatial",
    "canonical_rel_name": "located_at",
    "canonical_rel_desc": "Indicates that the subject is situated at, on, or within the spatial region or physical substrate denoted by the object.",
    "rel_cls": "spatial_location_relation",
    "rel_cls_group": "SPATIALITY",
    "subject_entity_name": "pupa stage of the butterfly life cycle",
    "object_entity_name": "stem",
    "subject_class_label": "Butterfly pupa (chrysalis) life stage",
    "subject_class_group": "TBD",
    "object_class_label": "Plant Structures as Lepidopteran Substrate and Background",
    "object_class_group": "Lepidopteran Plant Interactions & Habitat",
    "qualifiers": {
      "TemporalQualifier": "when forming the chrysalis at the start of the pupa stage",
      "SpatialQualifier": "attached to a plant stem",
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": "implied correspondence between chrysalis and pupa stage",
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "SubstrateType: plant stem or leaf"
    },
    "confidence": 0.7,
    "remarks": [
      "Relation created to capture spatial context of the pupa/chrysalis relative to the plant stem.",
      "Relation created to capture spatial context of the pupa/chrysalis relative to the plant stem.",
      "Relation created to capture spatial context of the pupa/chrysalis relative to the plant stem."
    ]
  },
  {
    "relation_id": "RelR_9227ea6b14cf",
    "relation_name": "has_ecological_role",
    "rel_desc": "Butterflies have an ecological role as a food source for various predators.",
    "rel_hint_type": "ecological role",
    "canonical_rel_name": "has_ecological_role",
    "canonical_rel_desc": "Indicates that an organism exhibits a specific ecological or functional role within an ecosystem.",
    "rel_cls": "ecological_role_relation",
    "rel_cls_group": "ASSOCIATION",
    "subject_entity_name": "butterfly",
    "object_entity_name": "food source role of butterflies",
    "subject_class_label": "Adult butterflies",
    "subject_class_group": "Butterfly Biology & Life Cycle",
    "object_class_label": "Butterfly Prey Role and Anti-predator Strategies",
    "object_class_group": "Ecology and Ecosystems",
    "qualifiers": {
      "TemporalQualifier": "throughout adult stage (primarily)",
      "SpatialQualifier": "within their ecosystem",
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": "serve as",
      "LogicalMarker": null,
      "OtherQualifier": null
    },
    "confidence": 0.95,
    "remarks": []
  },
  {
    "relation_id": "RelR_d7f799ddca5e",
    "relation_name": "exhibits_behavior",
    "rel_desc": "Adult butterflies exhibit mating behavior of finding a mate.",
    "rel_hint_type": "behavioral",
    "canonical_rel_name": "exhibits_behavior",
    "canonical_rel_desc": "Indicates that an organism or life stage displays or engages in a specific behavior.",
    "rel_cls": "reproductive_behavior_relation",
    "rel_cls_group": "AGENCY",
    "subject_entity_name": "butterfly",
    "object_entity_name": "mating behavior of butterflies",
    "subject_class_label": "Adult butterflies",
    "subject_class_group": "Butterfly Biology & Life Cycle",
    "object_class_label": "Butterfly Reproductive Behavior",
    "object_class_group": "Butterfly Life Cycle and Reproduction",
    "qualifiers": {
      "TemporalQualifier": "throughout their adult stage",
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": "during adult stage",
      "UncertaintyQualifier": null,
      "CausalHint": "focus on",
      "LogicalMarker": null,
      "OtherQualifier": null
    },
    "confidence": 0.94,
    "remarks": []
  },
  {
    "relation_id": "RelR_64c60c5bae68",
    "relation_name": "used_for",
    "rel_desc": "Early stories associated with the origins of urban legends were used for explaining the unknown.",
    "rel_hint_type": "functional use",
    "canonical_rel_name": "used_for",
    "canonical_rel_desc": "Indicates that the subject is used for a particular purpose or function expressed by the object.",
    "rel_cls": "functional_usage_relation",
    "rel_cls_group": "USAGE",
    "subject_entity_name": "origins of urban legends",
    "object_entity_name": "the unknown",
    "subject_class_label": "Urban Legend Research and Analysis",
    "subject_class_group": "Urban Legends – Folklore, Psychology & Scholarship",
    "object_class_label": "Supernatural Concepts",
    "object_class_group": "Supernatural & Paranormal Domain",
    "qualifiers": {
      "TemporalQualifier": "ancient times",
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": "used to explain",
      "LogicalMarker": null,
      "OtherQualifier": "ExplanationType: explanation of mysterious and supernatural phenomena"
    },
    "confidence": 0.8,
    "remarks": [
      "Subject approximates 'stories' via the broader origins-of-urban-legends concept.",
      "Subject approximates 'stories' via the broader origins-of-urban-legends concept.",
      "Subject approximates 'stories' via the broader origins-of-urban-legends concept."
    ]
  },
  {
    "relation_id": "RelR_51fcfa0b345f",
    "relation_name": "affects_belief_in",
    "rel_desc": "Blurring the line between fact and fiction in stories influences listeners’ questioning of the existence of the supernatural.",
    "rel_hint_type": "influence",
    "canonical_rel_name": "influences_belief_in",
    "canonical_rel_desc": "The subject affects the audience's belief or questioning regarding the existence or reality of the object.",
    "rel_cls": "conceptual_influence_relation",
    "rel_cls_group": "CAUSALITY",
    "subject_entity_name": "line between fact and fiction",
    "object_entity_name": "existence of the supernatural",
    "subject_class_label": "Fact and Fiction in Narratives",
    "subject_class_group": "Narrative Truth, Fiction, and History",
    "object_class_label": "Supernatural Concepts",
    "object_class_group": "Supernatural & Paranormal Domain",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": "leaving listeners to wonder",
      "CausalHint": "leaving",
      "LogicalMarker": null,
      "OtherQualifier": "AudienceEffect: prompts questioning of reality of supernatural phenomena"
    },
    "confidence": 0.86,
    "remarks": []
  },
  {
    "relation_id": "RelR_bee45680e312",
    "relation_name": "reaches",
    "rel_desc": "Stories disseminated online can reach a global audience.",
    "rel_hint_type": "communication",
    "canonical_rel_name": "reaches_audience",
    "canonical_rel_desc": "A story or narrative attains exposure to, or becomes accessible by, an audience.",
    "rel_cls": "narrative_dissemination_relation",
    "rel_cls_group": "COMMUNICATION",
    "subject_entity_name": "stories",
    "object_entity_name": "global audience",
    "subject_class_label": "Stories and Urban Legends",
    "subject_class_group": "Storytelling & Narrative Dissemination",
    "object_class_label": "Story and Legend Audiences (including Cautionary Narratives)",
    "object_class_group": "Storytelling & Narrative Dissemination",
    "qualifiers": {
      "TemporalQualifier": "in a matter of seconds",
      "SpatialQualifier": "global (worldwide)",
      "OperationalConstraint": "via internet and social media dissemination",
      "ConditionExpression": null,
      "UncertaintyQualifier": "can (potential reach)",
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "Speed: lightning speed"
    },
    "confidence": 0.97,
    "remarks": []
  },
  {
    "relation_id": "RelR_845dea97687a",
    "relation_name": "enables",
    "rel_desc": "Communication platforms and media enable or support the rapid transmission of information.",
    "rel_hint_type": "dependency",
    "canonical_rel_name": "enables",
    "canonical_rel_desc": "Indicates that the subject makes it possible for, or facilitates, the occurrence or efficiency of the object process or outcome.",
    "rel_cls": "capability_enabling_relation",
    "rel_cls_group": "CAUSALITY",
    "subject_entity_name": "communication platforms and media",
    "object_entity_name": "rapid transmission of information",
    "subject_class_label": "Digital & Networked Communication Media",
    "subject_class_group": "Story & Information Dissemination Mechanisms",
    "object_class_label": "Information Dissemination Processes",
    "object_class_group": "Story & Information Dissemination Mechanisms",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": "across various platforms and mediums",
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": "implied rather than explicitly stated",
      "CausalHint": null,
      "LogicalMarker": "as",
      "OtherQualifier": null
    },
    "confidence": 0.7,
    "remarks": [
      "Semantics partially inferred from typical communication dynamics.",
      "Semantics partially inferred from typical communication dynamics.",
      "Semantics partially inferred from typical communication dynamics."
    ]
  },
  {
    "relation_id": "RelR_ec56bbbee845",
    "relation_name": "related_to",
    "rel_desc": "The origins of urban legends are directly related to the question of the truth behind the stories.",
    "rel_hint_type": "conceptual_link",
    "canonical_rel_name": "conceptually_related_to",
    "canonical_rel_desc": "Indicates a non-causal, conceptual association between two ideas or domains.",
    "rel_cls": "conceptual_association_relation",
    "rel_cls_group": "ASSOCIATION",
    "subject_entity_name": "origins of urban legends",
    "object_entity_name": "truth behind the stories",
    "subject_class_label": "Urban Legend Research and Analysis",
    "subject_class_group": "Urban Legends – Folklore, Psychology & Scholarship",
    "object_class_label": "Fact and Fiction in Narratives",
    "object_class_group": "Narrative Truth, Fiction, and History",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": "remain shrouded in mystery",
      "CausalHint": null,
      "LogicalMarker": "Despite",
      "OtherQualifier": null
    },
    "confidence": 0.78,
    "remarks": [
      "Relation added to capture conceptual linkage between origin research and story truth.",
      "Relation added to capture conceptual linkage between origin research and story truth.",
      "Relation added to capture conceptual linkage between origin research and story truth."
    ]
  },
  {
    "relation_id": "RelR_f2ccdde0554e",
    "relation_name": "is_blurred_in",
    "rel_desc": "In urban legend tales, the line between fact and fiction is often blurred.",
    "rel_hint_type": "constraint",
    "canonical_rel_name": "is_blurred_within_context_of",
    "canonical_rel_desc": "Indicates that the conceptual boundary represented by the subject becomes indistinct or unclear within the narrative or situational context represented by the object.",
    "rel_cls": "narrative_truth_boundary_relation",
    "rel_cls_group": "MODIFICATION",
    "subject_entity_name": "line between fact and fiction",
    "object_entity_name": "proliferation of urban legends",
    "subject_class_label": "Fact and Fiction in Narratives",
    "subject_class_group": "Narrative Truth, Fiction, and History",
    "object_class_label": "Urban Legends",
    "object_class_group": "Urban Legends and Modern Folklore",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": "in these tales (urban legends)",
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": "often",
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": null
    },
    "confidence": 0.88,
    "remarks": []
  },
  {
    "relation_id": "RelR_a14119185038",
    "relation_name": "belongs_to",
    "rel_desc": "The fears and anxieties are held collectively by society.",
    "rel_hint_type": "ownership",
    "canonical_rel_name": "belongs_to",
    "canonical_rel_desc": "Indicates that the subject is owned by, attributed to, or collectively associated with the object (for example, fears belonging to a particular society).",
    "rel_cls": "possession_control_relation",
    "rel_cls_group": "AGENCY",
    "subject_entity_name": "fears and anxieties of society",
    "object_entity_name": "society",
    "subject_class_label": "Societal Fears and Anxieties in Legends",
    "subject_class_group": "Urban Legends Sociocultural Context",
    "object_class_label": "Societies as Bearers of Fears",
    "object_class_group": "Urban Legends Sociocultural Context",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": null,
      "LogicalMarker": "of",
      "OtherQualifier": null
    },
    "confidence": 0.95,
    "remarks": []
  }
]

--------------------------------
OUTPUT
--------------------------------

Return ONLY the JSON ARRAY of function calls, e.g.:

[
  {
    "function": "set_canonical_rel",
    "args": { ... }
  },
  {
    "function": "set_rel_cls",
    "args": { ... }
  },
  ...
]

- If this chunk is already perfect (rare), you MAY return [].
- Every call MUST include a "justification".
- Use "remark" (or add_rel_remark) to flag issues or uncertainties that are outside
  the scope of these functions.
