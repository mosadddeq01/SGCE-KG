
You are a very proactive RELATION-RESOLUTION assistant.

You are given a CLUSTER of relation INSTANCES from a context-enriched technical KG.
Each relation instance already connects specific subject and object entities, and has:

- relation_id
- relation_name        (raw, from Relation Recognition; may be noisy)
- rel_desc             (instance-level description; may be verbose)
- rel_hint_type        (short free-form hint; may be noisy)
- canonical_rel_name   (often "TBD" initially)
- canonical_rel_desc   (often empty initially)
- rel_cls              (often "TBD" initially)
- rel_cls_group        (often "TBD" initially)
- subject_entity_name, object_entity_name
- subject_class_label, subject_class_group
- object_class_label, object_class_group
- qualifiers (temporal, spatial, etc.)
- confidence, remarks, etc.

IMPORTANT CONTEXT ABOUT THE PIPELINE
------------------------------------
- ALL these fields (relation_name, rel_desc, rel_hint_type, qualifiers, etc.) were
  generated by previous LLM stages. They are **approximate** and may be:
    - awkward in wording,
    - too specific,
    - too generic,
    - or slightly wrong.
- This step follows a "generate first, refine later" philosophy.
  Your job is to **refine and normalize**, not to copy the wording blindly.
- Use upstream fields as **semantic hints**, not as final label candidates.

ABOUT CLUSTERS (CRITICAL)
-------------------------
- The cluster you see is produced automatically from embeddings.
- The cluster is **only suggestive**, NOT a hard class:
    - It may contain multiple different canonical relations.
    - It may contain multiple different relation classes and groups.
- Your task is **NOT**:
    - "Find ONE canonical_rel_name that covers all relations in the cluster."
    - "Force all relations in the cluster into the same rel_cls or rel_cls_group."
- Your task **IS**:
    - For EACH relation instance, decide what canonical_rel_name, rel_cls,
      and rel_cls_group are appropriate.
    - If some other instances in the cluster naturally share exactly the same
      semantics, group them together in the same function call.
    - If they do NOT naturally share semantics, assign them different
      canonical_rel_name / rel_cls / rel_cls_group, even though they are
      in the same cluster.

CRUCIAL DISTINCTION (SCOPE)
---------------------------
We use a 3-layer abstraction for relations:

1) canonical_rel_name
   - Fine-grained, predicate-level.
   - Groups relations that use essentially the SAME predicate meaning and direction.
   - This is the predicate that will be used as the edge label in the KG.
   - Examples: "occurs_in", "resists", "provides_resistance_to", "is_subtype_of",
     "has_metallurgical_structure", "grouped_with".

2) rel_cls
   - A broader relation CLASS that may cover multiple canonical_rel_name values.
   - Think of this as a family of similar predicates.
   - Examples (illustrative): "alloying_element_relation", "microstructure_relation",
     "hierarchy_relation", "corrosion_resistance_relation", "document_series_relation".
   - IMPORTANT: rel_cls should be more specific than broad groups, but more general
     than a single canonical_rel_name.

3) rel_cls_group
   - Very broad semantic DIMENSIONS:
       COMPOSITION, CAUSALITY, IDENTITY, TEMPORALITY, SPATIALITY, AGENCY,
       INTERACTION, ASSOCIATION, MODIFICATION, USAGE, REQUIREMENT, etc.
   - This list is illustrative, NOT exhaustive.
   - Example:
       canonical_rel_name: "contains_alloying_element"
       rel_cls:            "alloying_element_relation"
       rel_cls_group:      "COMPOSITION"

RELATION-BY-RELATION THINKING (SUPER IMPORTANT)
-----------------------------------------------
For every relation instance in the cluster, conceptually ask:

1) What is the **best canonical predicate** (canonical_rel_name) for THIS instance,
   ignoring awkward wording in relation_name / rel_hint_type?
2) Which broader **relation class** (rel_cls) best describes this connection?
3) Which **rel_cls_group** (COMPOSITION, CAUSALITY, etc.) does it belong to?

Then:
- If you see other instances in the cluster with the **same semantics**, you may
  include them in the same function call (same canonical_rel_name / rel_cls / rel_cls_group).
- Do NOT try to find one label that covers ALL instances in the cluster.

NOISY HINTS AND HOW TO USE THEM
-------------------------------
- relation_name, rel_desc, rel_hint_type are hints, not perfect labels.
- Examples of bad patterns that you should NOT copy directly:
    - rel_hint_type = "co-classification" → this is awkward wording; interpret it
      as "these things are grouped together as co-equal categories" and choose
      a better canonical name / class (e.g., "grouped_with" with rel_cls
      "coequal_category_relation", rel_cls_group "ASSOCIATION" or "IDENTITY").
    - rel_hint_type = "causal" → this suggests rel_cls_group "CAUSALITY",
      but is NOT a good canonical_rel_name or rel_cls by itself.
- Also avoid redundant patterns like:
    - rel_cls = "composition_relation" when rel_cls_group = "COMPOSITION".
      In that case, choose a more specific rel_cls label, e.g.,
      "alloying_element_relation" or "microstructure_relation".

DEDUPLICATION & NORMALIZATION
-----------------------------
- Within a cluster, if you see multiple predicate variants that are semantically
  the same (e.g., "has_subtype", "is_subtype_of"), you MUST normalize them
  to **one** canonical_rel_name and apply it consistently:
    - For hierarchical relations, prefer a single consistent style, e.g., "is_subtype_of".
- Avoid creating trivial variants that only differ in small wording:
    - Do NOT keep both "provides_resistance_to" and "improves_resistance_to"
      if they are used identically for the same semantic link; pick one.
- Avoid rel_cls that simply repeats rel_cls_group with "_relation" added
  (e.g., "composition_relation" when rel_cls_group is "COMPOSITION").

WHAT YOU NEVER CHANGE
----------------------
- SUBJECT and OBJECT entities are fixed; you MUST NOT change them.
- You NEVER delete relation instances.
- You NEVER move qualifiers from relations onto nodes; qualifiers stay on the
  relation instance.

YOUR FUNCTION VOCABULARY
------------------------
You must return an ordered JSON ARRAY of function calls using ONLY:

1) set_canonical_rel
2) set_rel_cls
3) set_rel_cls_group
4) modify_rel_schema
5) add_rel_remark

Think RELATION-BY-RELATION first, and only group multiple relation_ids into the
same function call when you are genuinely sure they share the same semantics.

--------------------------------
FUNCTION DEFINITIONS
--------------------------------

1) set_canonical_rel
   Use this when you want to SET or ALIGN canonical_rel_name / canonical_rel_desc
   for one or more relation instances (especially when values are "TBD").

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "canonical_rel_name": <string>,           # REQUIRED, normalized predicate for KG edge
     "canonical_rel_desc": <string or null>,   # OPTIONAL, reusable description of this predicate
     "justification": <string>,                # REQUIRED: why these instances share this canonical predicate
     "remark": <string or null>,               # optional human-facing notes
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - canonical_rel_name should be a short predicate-style phrase, e.g. "occurs_in",
     "resists", "provides_resistance_to", "is_subtype_of", "has_metallurgical_structure".
   - Do NOT include qualifiers (e.g., "at high temperature") here.
   - Use this on relatively TIGHT groups of semantically equivalent predicates.
   - It is perfectly fine to call set_canonical_rel with a **single** relation_id
     when others in the cluster do not share the semantics.


2) set_rel_cls
   Use this when you want to SET or ALIGN rel_cls for one or more instances,
   grouping them into a broader relation class (family).

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "rel_cls": <string>,                      # REQUIRED: class name (e.g., "structure_relation")
     "justification": <string>,                # REQUIRED: why these instances belong to this class
     "remark": <string or null>,               # optional notes
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - A rel_cls usually covers MULTIPLE canonical_rel_name values, not just one.
   - Think of rel_cls as a conceptual family: e.g. "alloying_element_relation",
     "microstructure_relation", "document_series_relation".
   - Do NOT simply repeat rel_cls_group (e.g. avoid "composition_relation" when
     rel_cls_group is "COMPOSITION") unless there is truly no more specific
     and meaningful class you can provide.


3) set_rel_cls_group
   Use this when you want to SET or ALIGN rel_cls_group for one or more instances
   (or their classes), using a very broad semantic category.

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "rel_cls_group": <string>,                # REQUIRED: broad group (e.g., "COMPOSITION")
     "justification": <string>,                # REQUIRED: why this group fits
     "remark": <string or null>,               # optional notes
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - rel_cls_group is broad and somewhat orthogonal.
   - Typical groups: COMPOSITION, CAUSALITY, IDENTITY, TEMPORALITY, SPATIALITY,
     AGENCY, INTERACTION, ASSOCIATION, MODIFICATION, USAGE, REQUIREMENT, etc.
   - General hints like rel_hint_type="causal" are better mapped to rel_cls_group
     (CAUSALITY) than to canonical_rel_name.


4) modify_rel_schema
   Use this to REFINE or CORRECT existing schema fields for one or more relations
   (canonical_rel_name / canonical_rel_desc / rel_cls / rel_cls_group),
   or in rare cases to adjust a bad relation_name.

   args = {
     "relation_ids": [<relation_id>...],            # REQUIRED, at least 1
     "canonical_rel_name": <string or null>,        # OPTIONAL: new canonical name
     "canonical_rel_desc": <string or null>,        # OPTIONAL: new canonical description
     "rel_cls": <string or null>,                   # OPTIONAL: new relation class
     "rel_cls_group": <string or null>,             # OPTIONAL: new broad group
     "new_relation_name": <string or null>,         # OPTIONAL: ONLY if raw relation_name is malformed
     "original_relation_name": <string or null>,    # REQUIRED if you change relation_name
     "justification": <string>,                     # REQUIRED: why this modification is needed
     "remark": <string or null>,                    # optional notes / flags
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - You should RARELY change relation_name (raw). Only do so if it is clearly malformed,
     misleading, or not a real predicate. Then you MUST provide original_relation_name
     and explain why the change is necessary.
   - You MAY use this to normalize minor variants (e.g., consolidate "has_subtype"
     and "is_subtype_of" to "is_subtype_of") when appropriate.


5) add_rel_remark
   Use this when you ONLY want to attach a human-facing remark / caveat / TODO
   without changing any schema fields.

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "remark": <string>,                        # REQUIRED: the remark text
     "justification": <string>,                # REQUIRED: why this remark is useful
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - Use this for issues outside scope (e.g., upstream entity resolution suspicion), or
     to flag ambiguous or borderline cases for later human review.

--------------------------------
INPUT RELATIONS (THIS CHUNK)
--------------------------------

Below is the JSON array of relation instances in THIS PART of a cluster
(we split very large clusters into smaller chunks just to keep the prompt size manageable):

[
  {
    "relation_id": "RelR_ccb0e0161188",
    "relation_name": "occurs_in",
    "rel_desc": "The austenitic structure is normally found in 300 Series austenitic stainless steels.",
    "rel_hint_type": "occurrence",
    "canonical_rel_name": "occurs_in",
    "canonical_rel_desc": "The subject phase, microstructural feature, damage mechanism, or process occurs within or in association with the object material or alloy, which serves as its host environment.",
    "rel_cls": "phenomenon_in_material_relation",
    "rel_cls_group": "SPATIALITY",
    "subject_entity_name": "austenitic",
    "object_entity_name": "austenitic stainless steels",
    "subject_class_label": "Austenitic Structure",
    "subject_class_group": "Steel Metallurgy",
    "object_class_label": "Austenitic Stainless Steels",
    "object_class_group": "Stainless Steel Classification",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": "normally",
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "AlloyScope: 300 Series stainless steels"
    },
    "confidence": 0.9,
    "remarks": [
      "Complements the alloy→structure relation by capturing where the structure is typically present.",
      "Complements the alloy→structure relation by capturing where the structure is typically present."
    ]
  },
  {
    "relation_id": "RelR_c426520a3c91",
    "relation_name": "occurs_in",
    "rel_desc": "Ferritic structure occurs as one phase within duplex stainless steels.",
    "rel_hint_type": "occurrence",
    "canonical_rel_name": "occurs_in",
    "canonical_rel_desc": "The subject phase, microstructural feature, damage mechanism, or process occurs within or in association with the object material or alloy, which serves as its host environment.",
    "rel_cls": "phenomenon_in_material_relation",
    "rel_cls_group": "SPATIALITY",
    "subject_entity_name": "ferritic",
    "object_entity_name": "duplex stainless steel",
    "subject_class_label": "Ferritic Structure",
    "subject_class_group": "Steel Metallurgy",
    "object_class_label": "Corrosion-Resistant Alloys",
    "object_class_group": "Corrosion-Resistant Metals and Alloys",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "StructureContext: part of mixed austenitic-ferritic phase balance"
    },
    "confidence": 0.86,
    "remarks": [
      "Redundant with the duplex→ferritic structural relation but captures the inverse perspective (where ferritic is found).",
      "Redundant with the duplex→ferritic structural relation but captures the inverse perspective (where ferritic is found)."
    ]
  },
  {
    "relation_id": "RelR_7c9bc782fce9",
    "relation_name": "occurs_in",
    "rel_desc": "Austenitic structure occurs as one phase within duplex stainless steels.",
    "rel_hint_type": "occurrence",
    "canonical_rel_name": "occurs_in",
    "canonical_rel_desc": "The subject phase, microstructural feature, damage mechanism, or process occurs within or in association with the object material or alloy, which serves as its host environment.",
    "rel_cls": "phenomenon_in_material_relation",
    "rel_cls_group": "SPATIALITY",
    "subject_entity_name": "austenitic",
    "object_entity_name": "duplex stainless steel",
    "subject_class_label": "Austenitic Structure",
    "subject_class_group": "Steel Metallurgy",
    "object_class_label": "Corrosion-Resistant Alloys",
    "object_class_group": "Corrosion-Resistant Metals and Alloys",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "StructureContext: part of mixed austenitic-ferritic phase balance"
    },
    "confidence": 0.86,
    "remarks": [
      "Inverse perspective of the duplex→austenitic structural relation, included for coverage of where the austenitic phase is found.",
      "Inverse perspective of the duplex→austenitic structural relation, included for coverage of where the austenitic phase is found."
    ]
  },
  {
    "relation_id": "RelR_caa4eec09380",
    "relation_name": "occurs_in",
    "rel_desc": "Hydrogen Induced Cracking (HIC) is described as a cracking mechanism that occurs in steels, which plausibly includes low alloy steels as a subset.",
    "rel_hint_type": "occurrence",
    "canonical_rel_name": "occurs_in",
    "canonical_rel_desc": "The subject phase, microstructural feature, damage mechanism, or process occurs within or in association with the object material or alloy, which serves as its host environment.",
    "rel_cls": "phenomenon_in_material_relation",
    "rel_cls_group": "SPATIALITY",
    "subject_entity_name": "Hydrogen Induced Cracking (HIC)",
    "object_entity_name": "low alloy steel",
    "subject_class_label": "Hydrogen-Induced Cracking Mechanisms",
    "subject_class_group": "Environmental Cracking Mechanisms",
    "object_class_label": "High-Temperature Steels",
    "object_class_group": "Steel Metallurgy and Degradation",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": "on different planes in the metal / steels; may connect to the metal surface",
      "OperationalConstraint": "no externally applied stress is needed for formation of HIC",
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": "because of internal pressure resulting from the accumulation of hydrogen",
      "LogicalMarker": null,
      "OtherQualifier": "CrackMechanism: stepwise internal cracks that connect adjacent hydrogen blisters; LinkMechanism: transgranular plastic shear"
    },
    "confidence": 0.38,
    "remarks": [
      "Relation added mainly to capture that HIC is a cracking mechanism relevant to steels, with low alloy steel treated as a representative steel family. Semantics somewhat generic; confidence reduced because the text does not explicitly name low alloy steels as HIC-susceptible.",
      "Relation added mainly to capture that HIC is a cracking mechanism relevant to steels, with low alloy steel treated as a representative steel family. Semantics somewhat generic; confidence reduced because the text does not explicitly name low alloy steels as HIC-susceptible."
    ]
  },
  {
    "relation_id": "RelR_704fe359a26f",
    "relation_name": "occurs_in",
    "rel_desc": "Graphitization occurs in low alloy C-Mo steels containing up to 1% Mo.",
    "rel_hint_type": "occurrence",
    "canonical_rel_name": "occurs_in",
    "canonical_rel_desc": "The subject phase, microstructural feature, damage mechanism, or process occurs within or in association with the object material or alloy, which serves as its host environment.",
    "rel_cls": "phenomenon_in_material_relation",
    "rel_cls_group": "SPATIALITY",
    "subject_entity_name": "graphitization",
    "object_entity_name": "low alloy C-Mo steel",
    "subject_class_label": "Graphitization (Process)",
    "subject_class_group": "Steel Metallurgy and Degradation",
    "object_class_label": "Graphitization-Susceptible Steels",
    "object_class_group": "Steel Metallurgy and Degradation",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": "with up to 1% Mo",
      "UncertaintyQualifier": null,
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "ObservationContext: field or service experience"
    },
    "confidence": 0.88,
    "remarks": []
  },
  {
    "relation_id": "RelR_81f81efb1983",
    "relation_name": "occurs_in",
    "rel_desc": "Graphite nodules are present in carbon steels as products of carbide decomposition at elevated temperatures.",
    "rel_hint_type": "occurrence",
    "canonical_rel_name": "occurs_in",
    "canonical_rel_desc": "The subject phase, microstructural feature, damage mechanism, or process occurs within or in association with the object material or alloy, which serves as its host environment.",
    "rel_cls": "phenomenon_in_material_relation",
    "rel_cls_group": "SPATIALITY",
    "subject_entity_name": "graphite nodules",
    "object_entity_name": "carbon steel",
    "subject_class_label": "Graphite Nodules (Product)",
    "subject_class_group": "Steel Metallurgy and Degradation",
    "object_class_label": "Graphitization-Susceptible Steels",
    "object_class_group": "Steel Metallurgy and Degradation",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": "within the steel matrix",
      "OperationalConstraint": "at elevated temperatures",
      "ConditionExpression": null,
      "UncertaintyQualifier": "may decompose into",
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "Origin: decomposition of carbide phases"
    },
    "confidence": 0.7,
    "remarks": [
      "Subjective mapping of the pronoun “these steels” to carbon steels; 0.5Mo steels are handled in a separate relation.",
      "Subjective mapping of the pronoun “these steels” to carbon steels; 0.5Mo steels are handled in a separate relation."
    ]
  },
  {
    "relation_id": "RelR_c686532b051c",
    "relation_name": "occurs_in",
    "rel_desc": "Graphite nodules can also occur in 0.5Mo steels under elevated temperature conditions.",
    "rel_hint_type": "occurrence",
    "canonical_rel_name": "occurs_in",
    "canonical_rel_desc": "The subject phase, microstructural feature, damage mechanism, or process occurs within or in association with the object material or alloy, which serves as its host environment.",
    "rel_cls": "phenomenon_in_material_relation",
    "rel_cls_group": "SPATIALITY",
    "subject_entity_name": "graphite nodules",
    "object_entity_name": "0.5Mo steel",
    "subject_class_label": "Graphite Nodules (Product)",
    "subject_class_group": "Steel Metallurgy and Degradation",
    "object_class_label": "Graphitization-Susceptible Steels",
    "object_class_group": "Steel Metallurgy and Degradation",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": "within the steel",
      "OperationalConstraint": "at elevated temperatures",
      "ConditionExpression": null,
      "UncertaintyQualifier": "may decompose into",
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "Origin: carbide phase decomposition associated with graphitization"
    },
    "confidence": 0.65,
    "remarks": [
      "Moderate uncertainty because the pronoun could be read as all previously mentioned affected steels.",
      "Moderate uncertainty because the pronoun could be read as all previously mentioned affected steels."
    ]
  }
]

--------------------------------
OUTPUT
--------------------------------

Return ONLY the JSON ARRAY of function calls, e.g.:

[
  {
    "function": "set_canonical_rel",
    "args": { ... }
  },
  {
    "function": "set_rel_cls",
    "args": { ... }
  },
  ...
]

- If this chunk is already perfect (rare), you MAY return [].
- Every call MUST include a "justification".
- Use "remark" (or add_rel_remark) to flag issues or uncertainties that are outside
  the scope of these functions.
