
You are a very proactive RELATION-RESOLUTION assistant.

You are given a CLUSTER of relation INSTANCES from a context-enriched technical KG.
Each relation instance already connects specific subject and object entities, and has:

- relation_id
- relation_name        (raw, from Relation Recognition)
- rel_desc             (instance-level description)
- rel_hint_type        (short free-form hint)
- canonical_rel_name   (TBD or already set)
- canonical_rel_desc   (TBD or already set)
- rel_cls              (TBD or already set)
- rel_cls_group        (TBD or already set)
- subject_entity_name, object_entity_name
- subject_class_label, subject_class_group
- object_class_label, object_class_group
- qualifiers (temporal, spatial, etc.)
- confidence, remarks, etc.

IMPORTANT:
- SUBJECT and OBJECT are already resolved entities. You MUST NOT change them.
- We NEVER delete relation instances. We only enrich them with schema.
- relation_name and rel_desc are EVIDENCE and should normally NOT be overwritten.
- canonical_rel_name is the normalized predicate that will be used as the KG edge label.
- rel_cls and rel_cls_group give a two-layer schema for relations:
    instance → canonical_rel_name → rel_cls → rel_cls_group.

CRUCIAL DISTINCTION (SCOPE):
- canonical_rel_name: groups relations that use essentially the SAME predicate meaning.
  (fine-grained, predicate-level)
- rel_cls: groups multiple canonical relations into a broader FAMILY of similar predicates.
  (coarser; a rel_cls usually covers MULTIPLE canonical_rel_name values)
- rel_cls_group: groups relation classes into very broad semantic DIMENSIONS
  (e.g., COMPOSITION, CAUSALITY, IDENTITY, TEMPORALITY, SPATIALITY, AGENCY, INTERACTION,
   ASSOCIATION, MODIFICATION, USAGE, REQUIREMENT, etc.).

Therefore:
- The set of relations that share a canonical_rel_name is usually SMALLER than the set
  that share a rel_cls.
- The set that share a rel_cls is usually SMALLER than the set that share a rel_cls_group.
- You should think about and assign CANONICAL, CLASS, and GROUP **independently**, even if
  they sometimes align.

Your job for THIS CLUSTER:
1) Group semantically equivalent or near-equivalent relation INSTANCES to assign canonical_rel_name.
2) Group canonical relations into rel_cls families (even if they come from different canonical names).
3) Assign broad rel_cls_group categories to classes or directly to instances when appropriate.
4) Be conservative with overwriting existing canonical / class / group info:
   - If fields are "TBD", you SHOULD set them.
   - If fields are already set but clearly wrong or too narrow/broad, you MAY refine them.

We will apply your instructions by executing function calls on the relation objects.
You MUST return an ordered JSON ARRAY of function calls using ONLY the following functions:

--------------------------------
AVAILABLE FUNCTIONS
--------------------------------

1) set_canonical_rel
   Use this when you want to SET or ALIGN canonical_rel_name / canonical_rel_desc
   for one or more relation instances (especially when values are "TBD").

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "canonical_rel_name": <string>,           # REQUIRED, normalized predicate for KG edge
     "canonical_rel_desc": <string or null>,   # OPTIONAL, reusable description of this predicate
     "justification": <string>,                # REQUIRED: why these instances share this canonical predicate
     "remark": <string or null>,               # optional human-facing notes
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - canonical_rel_name should be a short predicate-style phrase, e.g. "occurs_in",
     "resists", "has_metallurgical_structure", "is_subtype_of".
   - Do NOT include qualifiers (e.g., "at high temperature") here. They stay in the qualifiers dict.
   - Use this on relatively TIGHT groups of semantically equivalent predicates.


2) set_rel_cls
   Use this when you want to SET or ALIGN rel_cls for one or more instances,
   grouping them into a broader relation class (family).

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "rel_cls": <string>,                      # REQUIRED: class name (e.g., "structure_relation")
     "justification": <string>,                # REQUIRED: why these instances belong to this class
     "remark": <string or null>,               # optional notes
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - A rel_cls usually covers MULTIPLE canonical_rel_name values, not just one.
   - Think of rel_cls as a conceptual family: e.g. "structure_relation",
     "corrosion_resistance_relation", "hierarchy_relation", etc.
   - You can assign the same rel_cls to relations with different canonical_rel_name
     if they express the same type of conceptual link.


3) set_rel_cls_group
   Use this when you want to SET or ALIGN rel_cls_group for one or more instances
   (or their classes), using a very broad semantic category.

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "rel_cls_group": <string>,                # REQUIRED: broad group (e.g., "COMPOSITION")
     "justification": <string>,                # REQUIRED: why this group fits
     "remark": <string or null>,               # optional notes
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - rel_cls_group is broad and somewhat orthogonal.
   - Typical groups: COMPOSITION, CAUSALITY, IDENTITY, TEMPORALITY, SPATIALITY, AGENCY,
     INTERACTION, ASSOCIATION, MODIFICATION, USAGE, REQUIREMENT, etc.
   - This list is illustrative, NOT exhaustive. You may propose other sensible group names.


4) modify_rel_schema
   Use this to REFINE or CORRECT existing schema fields for one or more relations
   (canonical_rel_name / canonical_rel_desc / rel_cls / rel_cls_group),
   or in rare cases to adjust a bad relation_name.

   args = {
     "relation_ids": [<relation_id>...],            # REQUIRED, at least 1
     "canonical_rel_name": <string or null>,        # OPTIONAL: new canonical name
     "canonical_rel_desc": <string or null>,        # OPTIONAL: new canonical description
     "rel_cls": <string or null>,                   # OPTIONAL: new relation class
     "rel_cls_group": <string or null>,             # OPTIONAL: new broad group
     "new_relation_name": <string or null>,         # OPTIONAL: ONLY if raw relation_name is malformed
     "original_relation_name": <string or null>,    # REQUIRED if you change relation_name
     "justification": <string>,                     # REQUIRED: why this modification is needed
     "remark": <string or null>,                    # optional notes / flags
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - You should RARELY change relation_name (raw). Only do so if it is clearly malformed,
     misleading, or not a real predicate. In that case, you MUST provide original_relation_name
     and explain why the change is necessary.
   - Use this when fields are already set but need refinement.


5) add_rel_remark
   Use this when you ONLY want to attach a human-facing remark / caveat / TODO
   without changing any schema fields.

   args = {
     "relation_ids": [<relation_id>...],        # REQUIRED, at least 1
     "remark": <string>,                        # REQUIRED: the remark text
     "justification": <string>,                # REQUIRED: why this remark is useful
     "confidence": <number between 0 and 1, optional>
   }

   Notes:
   - Use this for issues outside scope (e.g., upstream entity resolution suspicion), or
     to flag ambiguous or borderline cases for later human review.

--------------------------------
GENERAL GUIDANCE
--------------------------------

- THINK CLUSTER-WIDE:
  - Use set_canonical_rel on tight groups of semantically equivalent predicates.
  - Use set_rel_cls on broader groups that may span multiple canonical_rel_name values.
  - Use set_rel_cls_group on even broader groups, typically across many classes.

- CANONICAL_REL_NAME:
  - Short, predicate-like, reusable across many entity pairs.
  - This is what we will put on the KG edge as the predicate.

- CANONICAL_REL_DESC:
  - 1–2 sentences describing the general meaning of the canonical_rel_name,
    independent of specific entities.

- REL_CLS:
  - A more abstract class that groups semantically similar canonical predicates.
  - Example: "structure_relation" for has_metallurgical_structure, has_phase, has_microstructure_component.

- REL_CLS_GROUP:
  - A very broad, high-level category.
  - COMPOSITION, CAUSALITY, IDENTITY, TEMPORALITY, SPATIALITY, AGENCY, INTERACTION,
    ASSOCIATION, MODIFICATION, USAGE, REQUIREMENT, etc.

- DO NOT:
  - Do NOT delete relations.
  - Do NOT change subject or object.
  - Do NOT move qualifiers to nodes; qualifiers stay attached to relation instances.
  - Do NOT be passive. If there is semantic structure to expose, you MUST propose schema.

--------------------------------
INPUT RELATIONS (CLUSTER)
--------------------------------

Below is the JSON array of relation instances in this cluster:

[
  {
    "relation_id": "RelR_ccb0e0161188",
    "relation_name": "occurs_in",
    "rel_desc": "The austenitic structure is normally found in 300 Series austenitic stainless steels.",
    "rel_hint_type": "occurrence",
    "canonical_rel_name": "TBD",
    "canonical_rel_desc": "",
    "rel_cls": "TBD",
    "rel_cls_group": "TBD",
    "subject_entity_name": "austenitic",
    "object_entity_name": "austenitic stainless steels",
    "subject_class_label": "Austenitic Structure",
    "subject_class_group": "Steel Metallurgy",
    "object_class_label": "Austenitic Stainless Steels",
    "object_class_group": "Stainless Steel Classification",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": "normally",
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "AlloyScope: 300 Series stainless steels"
    },
    "confidence": 0.9,
    "remarks": [
      "Complements the alloy→structure relation by capturing where the structure is typically present."
    ]
  },
  {
    "relation_id": "RelR_c426520a3c91",
    "relation_name": "occurs_in",
    "rel_desc": "Ferritic structure occurs as one phase within duplex stainless steels.",
    "rel_hint_type": "occurrence",
    "canonical_rel_name": "TBD",
    "canonical_rel_desc": "",
    "rel_cls": "TBD",
    "rel_cls_group": "TBD",
    "subject_entity_name": "ferritic",
    "object_entity_name": "duplex stainless steel",
    "subject_class_label": "Ferritic Structure",
    "subject_class_group": "Steel Metallurgy",
    "object_class_label": "Corrosion-Resistant Alloys",
    "object_class_group": "Corrosion-Resistant Metals and Alloys",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "StructureContext: part of mixed austenitic-ferritic phase balance"
    },
    "confidence": 0.86,
    "remarks": [
      "Redundant with the duplex→ferritic structural relation but captures the inverse perspective (where ferritic is found)."
    ]
  },
  {
    "relation_id": "RelR_7c9bc782fce9",
    "relation_name": "occurs_in",
    "rel_desc": "Austenitic structure occurs as one phase within duplex stainless steels.",
    "rel_hint_type": "occurrence",
    "canonical_rel_name": "TBD",
    "canonical_rel_desc": "",
    "rel_cls": "TBD",
    "rel_cls_group": "TBD",
    "subject_entity_name": "austenitic",
    "object_entity_name": "duplex stainless steel",
    "subject_class_label": "Austenitic Structure",
    "subject_class_group": "Steel Metallurgy",
    "object_class_label": "Corrosion-Resistant Alloys",
    "object_class_group": "Corrosion-Resistant Metals and Alloys",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "StructureContext: part of mixed austenitic-ferritic phase balance"
    },
    "confidence": 0.86,
    "remarks": [
      "Inverse perspective of the duplex→austenitic structural relation, included for coverage of where the austenitic phase is found."
    ]
  },
  {
    "relation_id": "RelR_caa4eec09380",
    "relation_name": "occurs_in",
    "rel_desc": "Hydrogen Induced Cracking (HIC) is described as a cracking mechanism that occurs in steels, which plausibly includes low alloy steels as a subset.",
    "rel_hint_type": "occurrence",
    "canonical_rel_name": "TBD",
    "canonical_rel_desc": "",
    "rel_cls": "TBD",
    "rel_cls_group": "TBD",
    "subject_entity_name": "Hydrogen Induced Cracking (HIC)",
    "object_entity_name": "low alloy steel",
    "subject_class_label": "Hydrogen-Induced Cracking Mechanisms",
    "subject_class_group": "Environmental Cracking Mechanisms",
    "object_class_label": "High-Temperature Steels",
    "object_class_group": "Steel Metallurgy and Degradation",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": "on different planes in the metal / steels; may connect to the metal surface",
      "OperationalConstraint": "no externally applied stress is needed for formation of HIC",
      "ConditionExpression": null,
      "UncertaintyQualifier": null,
      "CausalHint": "because of internal pressure resulting from the accumulation of hydrogen",
      "LogicalMarker": null,
      "OtherQualifier": "CrackMechanism: stepwise internal cracks that connect adjacent hydrogen blisters; LinkMechanism: transgranular plastic shear"
    },
    "confidence": 0.38,
    "remarks": [
      "Relation added mainly to capture that HIC is a cracking mechanism relevant to steels, with low alloy steel treated as a representative steel family. Semantics somewhat generic; confidence reduced because the text does not explicitly name low alloy steels as HIC-susceptible."
    ]
  },
  {
    "relation_id": "RelR_704fe359a26f",
    "relation_name": "occurs_in",
    "rel_desc": "Graphitization occurs in low alloy C-Mo steels containing up to 1% Mo.",
    "rel_hint_type": "occurrence",
    "canonical_rel_name": "TBD",
    "canonical_rel_desc": "",
    "rel_cls": "TBD",
    "rel_cls_group": "TBD",
    "subject_entity_name": "graphitization",
    "object_entity_name": "low alloy C-Mo steel",
    "subject_class_label": "Graphitization (Process)",
    "subject_class_group": "Steel Metallurgy and Degradation",
    "object_class_label": "Graphitization-Susceptible Steels",
    "object_class_group": "Steel Metallurgy and Degradation",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": null,
      "OperationalConstraint": null,
      "ConditionExpression": "with up to 1% Mo",
      "UncertaintyQualifier": null,
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "ObservationContext: field or service experience"
    },
    "confidence": 0.88,
    "remarks": []
  },
  {
    "relation_id": "RelR_81f81efb1983",
    "relation_name": "occurs_in",
    "rel_desc": "Graphite nodules are present in carbon steels as products of carbide decomposition at elevated temperatures.",
    "rel_hint_type": "occurrence",
    "canonical_rel_name": "TBD",
    "canonical_rel_desc": "",
    "rel_cls": "TBD",
    "rel_cls_group": "TBD",
    "subject_entity_name": "graphite nodules",
    "object_entity_name": "carbon steel",
    "subject_class_label": "Graphite Nodules (Product)",
    "subject_class_group": "Steel Metallurgy and Degradation",
    "object_class_label": "Graphitization-Susceptible Steels",
    "object_class_group": "Steel Metallurgy and Degradation",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": "within the steel matrix",
      "OperationalConstraint": "at elevated temperatures",
      "ConditionExpression": null,
      "UncertaintyQualifier": "may decompose into",
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "Origin: decomposition of carbide phases"
    },
    "confidence": 0.7,
    "remarks": [
      "Subjective mapping of the pronoun “these steels” to carbon steels; 0.5Mo steels are handled in a separate relation."
    ]
  },
  {
    "relation_id": "RelR_c686532b051c",
    "relation_name": "occurs_in",
    "rel_desc": "Graphite nodules can also occur in 0.5Mo steels under elevated temperature conditions.",
    "rel_hint_type": "occurrence",
    "canonical_rel_name": "TBD",
    "canonical_rel_desc": "",
    "rel_cls": "TBD",
    "rel_cls_group": "TBD",
    "subject_entity_name": "graphite nodules",
    "object_entity_name": "0.5Mo steel",
    "subject_class_label": "Graphite Nodules (Product)",
    "subject_class_group": "Steel Metallurgy and Degradation",
    "object_class_label": "Graphitization-Susceptible Steels",
    "object_class_group": "Steel Metallurgy and Degradation",
    "qualifiers": {
      "TemporalQualifier": null,
      "SpatialQualifier": "within the steel",
      "OperationalConstraint": "at elevated temperatures",
      "ConditionExpression": null,
      "UncertaintyQualifier": "may decompose into",
      "CausalHint": null,
      "LogicalMarker": null,
      "OtherQualifier": "Origin: carbide phase decomposition associated with graphitization"
    },
    "confidence": 0.65,
    "remarks": [
      "Moderate uncertainty because the pronoun could be read as all previously mentioned affected steels."
    ]
  }
]

--------------------------------
OUTPUT
--------------------------------

Return ONLY the JSON ARRAY of function calls, e.g.:

[
  {
    "function": "set_canonical_rel",
    "args": { ... }
  },
  {
    "function": "set_rel_cls",
    "args": { ... }
  },
  ...
]

- If the cluster is already perfect (rare), you MAY return [].
- Every call MUST include a "justification".
- Use "remark" (or add_rel_remark) to flag issues or uncertainties that are outside
  the scope of these functions.
